"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/calculations.ts":
/*!*****************************!*\
  !*** ./lib/calculations.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: function() { return /* binding */ CONSTANTS; },\n/* harmony export */   POLICY_OPTIONS: function() { return /* binding */ POLICY_OPTIONS; },\n/* harmony export */   calculateAspirationBand: function() { return /* binding */ calculateAspirationBand; },\n/* harmony export */   calculateEmployerCeiling: function() { return /* binding */ calculateEmployerCeiling; },\n/* harmony export */   calculateNashSolution: function() { return /* binding */ calculateNashSolution; },\n/* harmony export */   calculateNegotiationPlan: function() { return /* binding */ calculateNegotiationPlan; },\n/* harmony export */   calculateUtilityFloors: function() { return /* binding */ calculateUtilityFloors; },\n/* harmony export */   calculateWorkerAnchor: function() { return /* binding */ calculateWorkerAnchor; },\n/* harmony export */   calculateWorkerWalkAway: function() { return /* binding */ calculateWorkerWalkAway; },\n/* harmony export */   calculateZOPA: function() { return /* binding */ calculateZOPA; },\n/* harmony export */   generateChartData: function() { return /* binding */ generateChartData; },\n/* harmony export */   utilityEmployer: function() { return /* binding */ utilityEmployer; },\n/* harmony export */   utilityWorker: function() { return /* binding */ utilityWorker; }\n/* harmony export */ });\n// 常量定义\nconst CONSTANTS = {\n    base: 2500,\n    w_E_ideal: 2500,\n    w_E_max: 8000,\n    w_W_min: 3500,\n    w_W_ideal: 8000,\n    feasible_min: 3500,\n    feasible_max: 8000,\n    grid_step: 50,\n    employer_fallback_cost_money: 6000,\n    worker_fallback_income_money: 2490\n};\n// 政策情景映射\nconst POLICY_OPTIONS = [\n    {\n        label: \"一般保护（市场主导）\",\n        value: \"market\",\n        beta: 0.48\n    },\n    {\n        label: \"中度保护（偏向工人）\",\n        value: \"moderate\",\n        beta: 0.42\n    },\n    {\n        label: \"较强保护（集体谈判）\",\n        value: \"strong\",\n        beta: 0.35\n    },\n    {\n        label: \"强保护（强工会/强监管）\",\n        value: \"strongest\",\n        beta: 0.28\n    }\n];\n// 夹逼函数\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n// 四舍五入到最近的步长\nfunction roundToStep(value, step) {\n    return Math.round(value / step) * step;\n}\n// 计算Plan B映射的效用底线\nfunction calculateUtilityFloors(negotiationBreakdownCost, localMinimumWage, workerIdeal, workerMinimum) {\n    const { w_E_ideal } = CONSTANTS;\n    // 使用动态参数或默认值\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    const employer_fallback_cost = negotiationBreakdownCost || CONSTANTS.employer_fallback_cost_money;\n    const worker_fallback_income = localMinimumWage || CONSTANTS.worker_fallback_income_money;\n    const w_W_min = workerMinimum || CONSTANTS.w_W_min;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    const uE0_raw = 0.1 + 0.9 * (w_E_max - employer_fallback_cost) / (w_E_max - w_E_ideal);\n    const uW0_raw = 0.1 + 0.9 * (worker_fallback_income - w_W_min) / (w_W_ideal - w_W_min);\n    const u_E0 = clamp(uE0_raw, 0.1, 0.9);\n    const u_W0 = clamp(uW0_raw, 0.1, 0.9);\n    return {\n        u_E0,\n        u_W0\n    };\n}\n// 雇主效用函数\nfunction utilityEmployer(w, negotiationBreakdownCost) {\n    const { w_E_ideal } = CONSTANTS;\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    return clamp(0.1 + 0.9 * (w_E_max - w) / (w_E_max - w_E_ideal), 0, 1);\n}\n// 工人效用函数\nfunction utilityWorker(w, workerIdeal, workerMinimum) {\n    const w_W_min = workerMinimum || CONSTANTS.w_W_min;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    return clamp(0.1 + 0.9 * (w - w_W_min) / (w_W_ideal - w_W_min), 0, 1);\n}\n// Nash谈判解\nfunction calculateNashSolution(beta, u_E0, u_W0, negotiationBreakdownCost, workerIdeal, workerMinimum) {\n    const { feasible_min, feasible_max, grid_step } = CONSTANTS;\n    let bestWage = feasible_min;\n    let maxObjective = -Infinity;\n    let hasValidSolution = false;\n    for(let w = feasible_min; w <= feasible_max; w += grid_step){\n        const u_E = utilityEmployer(w, negotiationBreakdownCost);\n        const u_W = utilityWorker(w, workerIdeal, workerMinimum);\n        // 跳过无效区域\n        if (u_E <= u_E0 || u_W <= u_W0) continue;\n        hasValidSolution = true;\n        const objective = Math.pow(u_E - u_E0, beta) * Math.pow(u_W - u_W0, 1 - beta);\n        if (objective > maxObjective) {\n            maxObjective = objective;\n            bestWage = w;\n        } else if (objective === maxObjective) {\n            // 如果目标函数相等，选择更接近区间中点的\n            const midpoint = (feasible_min + feasible_max) / 2;\n            if (Math.abs(w - midpoint) < Math.abs(bestWage - midpoint)) {\n                bestWage = w;\n            }\n        }\n    }\n    // 如果没有找到有效解，返回null\n    if (!hasValidSolution) {\n        return null;\n    }\n    return bestWage;\n}\n// 计算工人底线工资\nfunction calculateWorkerWalkAway(u_W0, workerIdeal, workerMinimum) {\n    const { feasible_min, feasible_max, grid_step } = CONSTANTS;\n    const w_W_min = workerMinimum || CONSTANTS.w_W_min;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    const w_WA_raw = w_W_min + (u_W0 - 0.1) / 0.9 * (w_W_ideal - w_W_min);\n    const w_WA_clamped = clamp(w_WA_raw, feasible_min, feasible_max);\n    return roundToStep(w_WA_clamped, grid_step);\n}\n// 计算雇主无差异上限\nfunction calculateEmployerCeiling(u_E0, negotiationBreakdownCost) {\n    const { w_E_ideal, feasible_min, grid_step } = CONSTANTS;\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    const w_EMP_raw = w_E_max - (u_E0 - 0.1) / 0.9 * (w_E_max - w_E_ideal);\n    // 使用动态上限，不限制在固定的feasible_max\n    const dynamicMax = Math.max(CONSTANTS.feasible_max, w_E_max);\n    const w_EMP_clamped = clamp(w_EMP_raw, feasible_min, dynamicMax);\n    return roundToStep(w_EMP_clamped, grid_step);\n}\n// 计算ZOPA\nfunction calculateZOPA(w_WA, w_EMP) {\n    const { feasible_min, feasible_max } = CONSTANTS;\n    const zopa_min = Math.max(feasible_min, w_WA);\n    const zopa_max = Math.min(feasible_max, w_EMP);\n    return {\n        min: zopa_min,\n        max: zopa_max,\n        valid: zopa_min <= zopa_max\n    };\n}\n// 计算工人锚点价格\nfunction calculateWorkerAnchor(w_nash, w_EMP) {\n    const { grid_step } = CONSTANTS;\n    const w_anchor_raw = Math.min(w_nash + 0.08 * (w_EMP - w_nash), w_EMP);\n    return roundToStep(w_anchor_raw, grid_step);\n}\n// 计算期望区间\nfunction calculateAspirationBand(w_nash, w_WA, w_EMP) {\n    const { grid_step } = CONSTANTS;\n    const w_top_raw = Math.min(w_nash + 0.15 * (w_EMP - w_WA), w_EMP);\n    const w_floor_raw = Math.max(w_WA, w_nash - 0.05 * (w_nash - w_WA));\n    return {\n        top: roundToStep(w_top_raw, grid_step),\n        floor: roundToStep(w_floor_raw, grid_step)\n    };\n}\n// 主计算函数\nfunction calculateNegotiationPlan(policyValue, customAsk, negotiationBreakdownCost, localMinimumWage, workerIdeal, workerMinimum) {\n    const policy = POLICY_OPTIONS.find((p)=>p.value === policyValue) || POLICY_OPTIONS[2];\n    const beta = policy.beta;\n    const { u_E0, u_W0 } = calculateUtilityFloors(negotiationBreakdownCost, localMinimumWage, workerIdeal, workerMinimum);\n    const w_WA = calculateWorkerWalkAway(u_W0, workerIdeal, workerMinimum);\n    const w_EMP = calculateEmployerCeiling(u_E0, negotiationBreakdownCost);\n    const zopa = calculateZOPA(w_WA, w_EMP);\n    const w_nash = calculateNashSolution(beta, u_E0, u_W0, negotiationBreakdownCost, workerIdeal, workerMinimum);\n    // 检查是否有Nash解\n    if (w_nash === null) {\n        return {\n            policy,\n            beta,\n            u_E0,\n            u_W0,\n            w_nash: null,\n            w_anchor: null,\n            w_WA,\n            w_EMP,\n            zopa,\n            aspirationBand: null,\n            coefficients: {\n                c_nash: null,\n                c_anchor: null,\n                c_ask: customAsk ? customAsk / CONSTANTS.base : undefined\n            },\n            customAsk,\n            hasValidSolution: false,\n            errorMessage: \"工资期望过高，雇主效用不足，Nash解不存在\"\n        };\n    }\n    const w_anchor = calculateWorkerAnchor(w_nash, w_EMP);\n    const aspirationBand = calculateAspirationBand(w_nash, w_WA, w_EMP);\n    // 转换为加班系数\n    const c_nash = w_nash / CONSTANTS.base;\n    const c_anchor = w_anchor / CONSTANTS.base;\n    const c_ask = customAsk ? customAsk / CONSTANTS.base : undefined;\n    return {\n        policy,\n        beta,\n        u_E0,\n        u_W0,\n        w_nash,\n        w_anchor,\n        w_WA,\n        w_EMP,\n        zopa,\n        aspirationBand,\n        coefficients: {\n            c_nash,\n            c_anchor,\n            c_ask\n        },\n        customAsk,\n        hasValidSolution: true\n    };\n}\n// 生成图表数据\nfunction generateChartData(u_E0, u_W0, negotiationBreakdownCost, workerIdeal, workerMinimum) {\n    const { feasible_min, feasible_max, grid_step } = CONSTANTS;\n    const data = [];\n    for(let w = feasible_min; w <= feasible_max; w += grid_step){\n        const u_E = utilityEmployer(w, negotiationBreakdownCost);\n        const u_W = utilityWorker(w, workerIdeal, workerMinimum);\n        data.push({\n            wage: w,\n            u_E,\n            u_W,\n            nashProduct: u_E > u_E0 && u_W > u_W0 ? (u_E - u_E0) * (u_W - u_W0) : 0\n        });\n    }\n    return data;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9jYWxjdWxhdGlvbnMudHM/M2Y3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyDluLjph4/lrprkuYlcbmV4cG9ydCBjb25zdCBDT05TVEFOVFMgPSB7XG4gIGJhc2U6IDI1MDAsXG4gIHdfRV9pZGVhbDogMjUwMCxcbiAgd19FX21heDogODAwMCxcbiAgd19XX21pbjogMzUwMCxcbiAgd19XX2lkZWFsOiA4MDAwLFxuICBmZWFzaWJsZV9taW46IDM1MDAsXG4gIGZlYXNpYmxlX21heDogODAwMCxcbiAgZ3JpZF9zdGVwOiA1MCxcbiAgZW1wbG95ZXJfZmFsbGJhY2tfY29zdF9tb25leTogNjAwMCxcbiAgd29ya2VyX2ZhbGxiYWNrX2luY29tZV9tb25leTogMjQ5MFxufTtcblxuLy8g5pS/562W5oOF5pmv5pig5bCEXG5leHBvcnQgY29uc3QgUE9MSUNZX09QVElPTlMgPSBbXG4gIHsgbGFiZWw6IFwi5LiA6Iis5L+d5oqk77yI5biC5Zy65Li75a+877yJXCIsIHZhbHVlOiBcIm1hcmtldFwiLCBiZXRhOiAwLjQ4IH0sXG4gIHsgbGFiZWw6IFwi5Lit5bqm5L+d5oqk77yI5YGP5ZCR5bel5Lq677yJXCIsIHZhbHVlOiBcIm1vZGVyYXRlXCIsIGJldGE6IDAuNDIgfSxcbiAgeyBsYWJlbDogXCLovoPlvLrkv53miqTvvIjpm4bkvZPosIjliKTvvIlcIiwgdmFsdWU6IFwic3Ryb25nXCIsIGJldGE6IDAuMzUgfSxcbiAgeyBsYWJlbDogXCLlvLrkv53miqTvvIjlvLrlt6XkvJov5by655uR566h77yJXCIsIHZhbHVlOiBcInN0cm9uZ2VzdFwiLCBiZXRhOiAwLjI4IH1cbl07XG5cbi8vIOWkuemAvOWHveaVsFxuZnVuY3Rpb24gY2xhbXAodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuXG4vLyDlm5voiI3kupTlhaXliLDmnIDov5HnmoTmraXplb9cbmZ1bmN0aW9uIHJvdW5kVG9TdGVwKHZhbHVlOiBudW1iZXIsIHN0ZXA6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gc3RlcCkgKiBzdGVwO1xufVxuXG4vLyDorqHnrpdQbGFuIELmmKDlsITnmoTmlYjnlKjlupXnur9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVVdGlsaXR5Rmxvb3JzKG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdD86IG51bWJlciwgbG9jYWxNaW5pbXVtV2FnZT86IG51bWJlciwgd29ya2VySWRlYWw/OiBudW1iZXIsIHdvcmtlck1pbmltdW0/OiBudW1iZXIpIHtcbiAgY29uc3QgeyB3X0VfaWRlYWwgfSA9IENPTlNUQU5UUztcbiAgXG4gIC8vIOS9v+eUqOWKqOaAgeWPguaVsOaIlum7mOiupOWAvFxuICBjb25zdCB3X0VfbWF4ID0gbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0IHx8IENPTlNUQU5UUy53X0VfbWF4O1xuICBjb25zdCBlbXBsb3llcl9mYWxsYmFja19jb3N0ID0gbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0IHx8IENPTlNUQU5UUy5lbXBsb3llcl9mYWxsYmFja19jb3N0X21vbmV5O1xuICBjb25zdCB3b3JrZXJfZmFsbGJhY2tfaW5jb21lID0gbG9jYWxNaW5pbXVtV2FnZSB8fCBDT05TVEFOVFMud29ya2VyX2ZhbGxiYWNrX2luY29tZV9tb25leTtcbiAgY29uc3Qgd19XX21pbiA9IHdvcmtlck1pbmltdW0gfHwgQ09OU1RBTlRTLndfV19taW47XG4gIGNvbnN0IHdfV19pZGVhbCA9IHdvcmtlcklkZWFsIHx8IENPTlNUQU5UUy53X1dfaWRlYWw7XG4gIFxuICBjb25zdCB1RTBfcmF3ID0gMC4xICsgMC45ICogKHdfRV9tYXggLSBlbXBsb3llcl9mYWxsYmFja19jb3N0KSAvICh3X0VfbWF4IC0gd19FX2lkZWFsKTtcbiAgY29uc3QgdVcwX3JhdyA9IDAuMSArIDAuOSAqICh3b3JrZXJfZmFsbGJhY2tfaW5jb21lIC0gd19XX21pbikgLyAod19XX2lkZWFsIC0gd19XX21pbik7XG4gIFxuICBjb25zdCB1X0UwID0gY2xhbXAodUUwX3JhdywgMC4xLCAwLjkpO1xuICBjb25zdCB1X1cwID0gY2xhbXAodVcwX3JhdywgMC4xLCAwLjkpO1xuICBcbiAgcmV0dXJuIHsgdV9FMCwgdV9XMCB9O1xufVxuXG4vLyDpm4fkuLvmlYjnlKjlh73mlbBcbmV4cG9ydCBmdW5jdGlvbiB1dGlsaXR5RW1wbG95ZXIodzogbnVtYmVyLCBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3Q/OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB7IHdfRV9pZGVhbCB9ID0gQ09OU1RBTlRTO1xuICBjb25zdCB3X0VfbWF4ID0gbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0IHx8IENPTlNUQU5UUy53X0VfbWF4O1xuICByZXR1cm4gY2xhbXAoMC4xICsgMC45ICogKHdfRV9tYXggLSB3KSAvICh3X0VfbWF4IC0gd19FX2lkZWFsKSwgMCwgMSk7XG59XG5cbi8vIOW3peS6uuaViOeUqOWHveaVsFxuZXhwb3J0IGZ1bmN0aW9uIHV0aWxpdHlXb3JrZXIodzogbnVtYmVyLCB3b3JrZXJJZGVhbD86IG51bWJlciwgd29ya2VyTWluaW11bT86IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHdfV19taW4gPSB3b3JrZXJNaW5pbXVtIHx8IENPTlNUQU5UUy53X1dfbWluO1xuICBjb25zdCB3X1dfaWRlYWwgPSB3b3JrZXJJZGVhbCB8fCBDT05TVEFOVFMud19XX2lkZWFsO1xuICByZXR1cm4gY2xhbXAoMC4xICsgMC45ICogKHcgLSB3X1dfbWluKSAvICh3X1dfaWRlYWwgLSB3X1dfbWluKSwgMCwgMSk7XG59XG5cbi8vIE5hc2josIjliKTop6NcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVOYXNoU29sdXRpb24oYmV0YTogbnVtYmVyLCB1X0UwOiBudW1iZXIsIHVfVzA6IG51bWJlciwgbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0PzogbnVtYmVyLCB3b3JrZXJJZGVhbD86IG51bWJlciwgd29ya2VyTWluaW11bT86IG51bWJlcik6IG51bWJlciB8IG51bGwge1xuICBjb25zdCB7IGZlYXNpYmxlX21pbiwgZmVhc2libGVfbWF4LCBncmlkX3N0ZXAgfSA9IENPTlNUQU5UUztcbiAgXG4gIGxldCBiZXN0V2FnZSA9IGZlYXNpYmxlX21pbjtcbiAgbGV0IG1heE9iamVjdGl2ZSA9IC1JbmZpbml0eTtcbiAgbGV0IGhhc1ZhbGlkU29sdXRpb24gPSBmYWxzZTtcbiAgXG4gIGZvciAobGV0IHcgPSBmZWFzaWJsZV9taW47IHcgPD0gZmVhc2libGVfbWF4OyB3ICs9IGdyaWRfc3RlcCkge1xuICAgIGNvbnN0IHVfRSA9IHV0aWxpdHlFbXBsb3llcih3LCBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QpO1xuICAgIGNvbnN0IHVfVyA9IHV0aWxpdHlXb3JrZXIodywgd29ya2VySWRlYWwsIHdvcmtlck1pbmltdW0pO1xuICAgIFxuICAgIC8vIOi3s+i/h+aXoOaViOWMuuWfn1xuICAgIGlmICh1X0UgPD0gdV9FMCB8fCB1X1cgPD0gdV9XMCkgY29udGludWU7XG4gICAgXG4gICAgaGFzVmFsaWRTb2x1dGlvbiA9IHRydWU7XG4gICAgY29uc3Qgb2JqZWN0aXZlID0gTWF0aC5wb3codV9FIC0gdV9FMCwgYmV0YSkgKiBNYXRoLnBvdyh1X1cgLSB1X1cwLCAxIC0gYmV0YSk7XG4gICAgXG4gICAgaWYgKG9iamVjdGl2ZSA+IG1heE9iamVjdGl2ZSkge1xuICAgICAgbWF4T2JqZWN0aXZlID0gb2JqZWN0aXZlO1xuICAgICAgYmVzdFdhZ2UgPSB3O1xuICAgIH0gZWxzZSBpZiAob2JqZWN0aXZlID09PSBtYXhPYmplY3RpdmUpIHtcbiAgICAgIC8vIOWmguaenOebruagh+WHveaVsOebuOetie+8jOmAieaLqeabtOaOpei/keWMuumXtOS4reeCueeahFxuICAgICAgY29uc3QgbWlkcG9pbnQgPSAoZmVhc2libGVfbWluICsgZmVhc2libGVfbWF4KSAvIDI7XG4gICAgICBpZiAoTWF0aC5hYnModyAtIG1pZHBvaW50KSA8IE1hdGguYWJzKGJlc3RXYWdlIC0gbWlkcG9pbnQpKSB7XG4gICAgICAgIGJlc3RXYWdlID0gdztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIOWmguaenOayoeacieaJvuWIsOacieaViOino++8jOi/lOWbnm51bGxcbiAgaWYgKCFoYXNWYWxpZFNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIHJldHVybiBiZXN0V2FnZTtcbn1cblxuLy8g6K6h566X5bel5Lq65bqV57q/5bel6LWEXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlV29ya2VyV2Fsa0F3YXkodV9XMDogbnVtYmVyLCB3b3JrZXJJZGVhbD86IG51bWJlciwgd29ya2VyTWluaW11bT86IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHsgZmVhc2libGVfbWluLCBmZWFzaWJsZV9tYXgsIGdyaWRfc3RlcCB9ID0gQ09OU1RBTlRTO1xuICBjb25zdCB3X1dfbWluID0gd29ya2VyTWluaW11bSB8fCBDT05TVEFOVFMud19XX21pbjtcbiAgY29uc3Qgd19XX2lkZWFsID0gd29ya2VySWRlYWwgfHwgQ09OU1RBTlRTLndfV19pZGVhbDtcbiAgXG4gIGNvbnN0IHdfV0FfcmF3ID0gd19XX21pbiArICgodV9XMCAtIDAuMSkgLyAwLjkpICogKHdfV19pZGVhbCAtIHdfV19taW4pO1xuICBjb25zdCB3X1dBX2NsYW1wZWQgPSBjbGFtcCh3X1dBX3JhdywgZmVhc2libGVfbWluLCBmZWFzaWJsZV9tYXgpO1xuICBcbiAgcmV0dXJuIHJvdW5kVG9TdGVwKHdfV0FfY2xhbXBlZCwgZ3JpZF9zdGVwKTtcbn1cblxuLy8g6K6h566X6ZuH5Li75peg5beu5byC5LiK6ZmQXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRW1wbG95ZXJDZWlsaW5nKHVfRTA6IG51bWJlciwgbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0PzogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgeyB3X0VfaWRlYWwsIGZlYXNpYmxlX21pbiwgZ3JpZF9zdGVwIH0gPSBDT05TVEFOVFM7XG4gIGNvbnN0IHdfRV9tYXggPSBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QgfHwgQ09OU1RBTlRTLndfRV9tYXg7XG4gIFxuICBjb25zdCB3X0VNUF9yYXcgPSB3X0VfbWF4IC0gKCh1X0UwIC0gMC4xKSAvIDAuOSkgKiAod19FX21heCAtIHdfRV9pZGVhbCk7XG4gIC8vIOS9v+eUqOWKqOaAgeS4iumZkO+8jOS4jemZkOWItuWcqOWbuuWumueahGZlYXNpYmxlX21heFxuICBjb25zdCBkeW5hbWljTWF4ID0gTWF0aC5tYXgoQ09OU1RBTlRTLmZlYXNpYmxlX21heCwgd19FX21heCk7XG4gIGNvbnN0IHdfRU1QX2NsYW1wZWQgPSBjbGFtcCh3X0VNUF9yYXcsIGZlYXNpYmxlX21pbiwgZHluYW1pY01heCk7XG4gIFxuICByZXR1cm4gcm91bmRUb1N0ZXAod19FTVBfY2xhbXBlZCwgZ3JpZF9zdGVwKTtcbn1cblxuLy8g6K6h566XWk9QQVxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVpPUEEod19XQTogbnVtYmVyLCB3X0VNUDogbnVtYmVyKTogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXI7IHZhbGlkOiBib29sZWFuIH0ge1xuICBjb25zdCB7IGZlYXNpYmxlX21pbiwgZmVhc2libGVfbWF4IH0gPSBDT05TVEFOVFM7XG4gIFxuICBjb25zdCB6b3BhX21pbiA9IE1hdGgubWF4KGZlYXNpYmxlX21pbiwgd19XQSk7XG4gIGNvbnN0IHpvcGFfbWF4ID0gTWF0aC5taW4oZmVhc2libGVfbWF4LCB3X0VNUCk7XG4gIFxuICByZXR1cm4ge1xuICAgIG1pbjogem9wYV9taW4sXG4gICAgbWF4OiB6b3BhX21heCxcbiAgICB2YWxpZDogem9wYV9taW4gPD0gem9wYV9tYXhcbiAgfTtcbn1cblxuLy8g6K6h566X5bel5Lq66ZSa54K55Lu35qC8XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlV29ya2VyQW5jaG9yKHdfbmFzaDogbnVtYmVyLCB3X0VNUDogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgeyBncmlkX3N0ZXAgfSA9IENPTlNUQU5UUztcbiAgXG4gIGNvbnN0IHdfYW5jaG9yX3JhdyA9IE1hdGgubWluKHdfbmFzaCArIDAuMDggKiAod19FTVAgLSB3X25hc2gpLCB3X0VNUCk7XG4gIHJldHVybiByb3VuZFRvU3RlcCh3X2FuY2hvcl9yYXcsIGdyaWRfc3RlcCk7XG59XG5cbi8vIOiuoeeul+acn+acm+WMuumXtFxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUFzcGlyYXRpb25CYW5kKHdfbmFzaDogbnVtYmVyLCB3X1dBOiBudW1iZXIsIHdfRU1QOiBudW1iZXIpOiB7IHRvcDogbnVtYmVyOyBmbG9vcjogbnVtYmVyIH0ge1xuICBjb25zdCB7IGdyaWRfc3RlcCB9ID0gQ09OU1RBTlRTO1xuICBcbiAgY29uc3Qgd190b3BfcmF3ID0gTWF0aC5taW4od19uYXNoICsgMC4xNSAqICh3X0VNUCAtIHdfV0EpLCB3X0VNUCk7XG4gIGNvbnN0IHdfZmxvb3JfcmF3ID0gTWF0aC5tYXgod19XQSwgd19uYXNoIC0gMC4wNSAqICh3X25hc2ggLSB3X1dBKSk7XG4gIFxuICByZXR1cm4ge1xuICAgIHRvcDogcm91bmRUb1N0ZXAod190b3BfcmF3LCBncmlkX3N0ZXApLFxuICAgIGZsb29yOiByb3VuZFRvU3RlcCh3X2Zsb29yX3JhdywgZ3JpZF9zdGVwKVxuICB9O1xufVxuXG4vLyDkuLvorqHnrpflh73mlbBcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVOZWdvdGlhdGlvblBsYW4ocG9saWN5VmFsdWU6IHN0cmluZywgY3VzdG9tQXNrPzogbnVtYmVyLCBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3Q/OiBudW1iZXIsIGxvY2FsTWluaW11bVdhZ2U/OiBudW1iZXIsIHdvcmtlcklkZWFsPzogbnVtYmVyLCB3b3JrZXJNaW5pbXVtPzogbnVtYmVyKSB7XG4gIGNvbnN0IHBvbGljeSA9IFBPTElDWV9PUFRJT05TLmZpbmQocCA9PiBwLnZhbHVlID09PSBwb2xpY3lWYWx1ZSkgfHwgUE9MSUNZX09QVElPTlNbMl07XG4gIGNvbnN0IGJldGEgPSBwb2xpY3kuYmV0YTtcbiAgXG4gIGNvbnN0IHsgdV9FMCwgdV9XMCB9ID0gY2FsY3VsYXRlVXRpbGl0eUZsb29ycyhuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QsIGxvY2FsTWluaW11bVdhZ2UsIHdvcmtlcklkZWFsLCB3b3JrZXJNaW5pbXVtKTtcbiAgXG4gIGNvbnN0IHdfV0EgPSBjYWxjdWxhdGVXb3JrZXJXYWxrQXdheSh1X1cwLCB3b3JrZXJJZGVhbCwgd29ya2VyTWluaW11bSk7XG4gIGNvbnN0IHdfRU1QID0gY2FsY3VsYXRlRW1wbG95ZXJDZWlsaW5nKHVfRTAsIG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdCk7XG4gIGNvbnN0IHpvcGEgPSBjYWxjdWxhdGVaT1BBKHdfV0EsIHdfRU1QKTtcbiAgXG4gIGNvbnN0IHdfbmFzaCA9IGNhbGN1bGF0ZU5hc2hTb2x1dGlvbihiZXRhLCB1X0UwLCB1X1cwLCBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QsIHdvcmtlcklkZWFsLCB3b3JrZXJNaW5pbXVtKTtcbiAgXG4gIC8vIOajgOafpeaYr+WQpuaciU5hc2jop6NcbiAgaWYgKHdfbmFzaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb2xpY3ksXG4gICAgICBiZXRhLFxuICAgICAgdV9FMCxcbiAgICAgIHVfVzAsXG4gICAgICB3X25hc2g6IG51bGwsXG4gICAgICB3X2FuY2hvcjogbnVsbCxcbiAgICAgIHdfV0EsXG4gICAgICB3X0VNUCxcbiAgICAgIHpvcGEsXG4gICAgICBhc3BpcmF0aW9uQmFuZDogbnVsbCxcbiAgICAgIGNvZWZmaWNpZW50czoge1xuICAgICAgICBjX25hc2g6IG51bGwsXG4gICAgICAgIGNfYW5jaG9yOiBudWxsLFxuICAgICAgICBjX2FzazogY3VzdG9tQXNrID8gY3VzdG9tQXNrIC8gQ09OU1RBTlRTLmJhc2UgOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICBjdXN0b21Bc2ssXG4gICAgICBoYXNWYWxpZFNvbHV0aW9uOiBmYWxzZSxcbiAgICAgIGVycm9yTWVzc2FnZTogXCLlt6XotYTmnJ/mnJvov4fpq5jvvIzpm4fkuLvmlYjnlKjkuI3otrPvvIxOYXNo6Kej5LiN5a2Y5ZyoXCJcbiAgICB9O1xuICB9XG4gIFxuICBjb25zdCB3X2FuY2hvciA9IGNhbGN1bGF0ZVdvcmtlckFuY2hvcih3X25hc2gsIHdfRU1QKTtcbiAgY29uc3QgYXNwaXJhdGlvbkJhbmQgPSBjYWxjdWxhdGVBc3BpcmF0aW9uQmFuZCh3X25hc2gsIHdfV0EsIHdfRU1QKTtcbiAgXG4gIC8vIOi9rOaNouS4uuWKoOePreezu+aVsFxuICBjb25zdCBjX25hc2ggPSB3X25hc2ggLyBDT05TVEFOVFMuYmFzZTtcbiAgY29uc3QgY19hbmNob3IgPSB3X2FuY2hvciAvIENPTlNUQU5UUy5iYXNlO1xuICBjb25zdCBjX2FzayA9IGN1c3RvbUFzayA/IGN1c3RvbUFzayAvIENPTlNUQU5UUy5iYXNlIDogdW5kZWZpbmVkO1xuICBcbiAgcmV0dXJuIHtcbiAgICBwb2xpY3ksXG4gICAgYmV0YSxcbiAgICB1X0UwLFxuICAgIHVfVzAsXG4gICAgd19uYXNoLFxuICAgIHdfYW5jaG9yLFxuICAgIHdfV0EsXG4gICAgd19FTVAsXG4gICAgem9wYSxcbiAgICBhc3BpcmF0aW9uQmFuZCxcbiAgICBjb2VmZmljaWVudHM6IHtcbiAgICAgIGNfbmFzaCxcbiAgICAgIGNfYW5jaG9yLFxuICAgICAgY19hc2tcbiAgICB9LFxuICAgIGN1c3RvbUFzayxcbiAgICBoYXNWYWxpZFNvbHV0aW9uOiB0cnVlXG4gIH07XG59XG5cbi8vIOWbvuihqOaVsOaNruexu+Wei1xuZXhwb3J0IGludGVyZmFjZSBDaGFydERhdGFQb2ludCB7XG4gIHdhZ2U6IG51bWJlcjtcbiAgdV9FOiBudW1iZXI7XG4gIHVfVzogbnVtYmVyO1xuICBuYXNoUHJvZHVjdDogbnVtYmVyO1xufVxuXG4vLyDnlJ/miJDlm77ooajmlbDmja5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNoYXJ0RGF0YSh1X0UwOiBudW1iZXIsIHVfVzA6IG51bWJlciwgbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0PzogbnVtYmVyLCB3b3JrZXJJZGVhbD86IG51bWJlciwgd29ya2VyTWluaW11bT86IG51bWJlcik6IENoYXJ0RGF0YVBvaW50W10ge1xuICBjb25zdCB7IGZlYXNpYmxlX21pbiwgZmVhc2libGVfbWF4LCBncmlkX3N0ZXAgfSA9IENPTlNUQU5UUztcbiAgY29uc3QgZGF0YTogQ2hhcnREYXRhUG9pbnRbXSA9IFtdO1xuICBcbiAgZm9yIChsZXQgdyA9IGZlYXNpYmxlX21pbjsgdyA8PSBmZWFzaWJsZV9tYXg7IHcgKz0gZ3JpZF9zdGVwKSB7XG4gICAgY29uc3QgdV9FID0gdXRpbGl0eUVtcGxveWVyKHcsIG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdCk7XG4gICAgY29uc3QgdV9XID0gdXRpbGl0eVdvcmtlcih3LCB3b3JrZXJJZGVhbCwgd29ya2VyTWluaW11bSk7XG4gICAgXG4gICAgZGF0YS5wdXNoKHtcbiAgICAgIHdhZ2U6IHcsXG4gICAgICB1X0UsXG4gICAgICB1X1csXG4gICAgICBuYXNoUHJvZHVjdDogKHVfRSA+IHVfRTAgJiYgdV9XID4gdV9XMCkgPyAodV9FIC0gdV9FMCkgKiAodV9XIC0gdV9XMCkgOiAwXG4gICAgfSk7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhO1xufSJdLCJuYW1lcyI6WyJDT05TVEFOVFMiLCJiYXNlIiwid19FX2lkZWFsIiwid19FX21heCIsIndfV19taW4iLCJ3X1dfaWRlYWwiLCJmZWFzaWJsZV9taW4iLCJmZWFzaWJsZV9tYXgiLCJncmlkX3N0ZXAiLCJlbXBsb3llcl9mYWxsYmFja19jb3N0X21vbmV5Iiwid29ya2VyX2ZhbGxiYWNrX2luY29tZV9tb25leSIsIlBPTElDWV9PUFRJT05TIiwibGFiZWwiLCJ2YWx1ZSIsImJldGEiLCJjbGFtcCIsIm1pbiIsIm1heCIsIk1hdGgiLCJyb3VuZFRvU3RlcCIsInN0ZXAiLCJyb3VuZCIsImNhbGN1bGF0ZVV0aWxpdHlGbG9vcnMiLCJuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QiLCJsb2NhbE1pbmltdW1XYWdlIiwid29ya2VySWRlYWwiLCJ3b3JrZXJNaW5pbXVtIiwiZW1wbG95ZXJfZmFsbGJhY2tfY29zdCIsIndvcmtlcl9mYWxsYmFja19pbmNvbWUiLCJ1RTBfcmF3IiwidVcwX3JhdyIsInVfRTAiLCJ1X1cwIiwidXRpbGl0eUVtcGxveWVyIiwidyIsInV0aWxpdHlXb3JrZXIiLCJjYWxjdWxhdGVOYXNoU29sdXRpb24iLCJiZXN0V2FnZSIsIm1heE9iamVjdGl2ZSIsIkluZmluaXR5IiwiaGFzVmFsaWRTb2x1dGlvbiIsInVfRSIsInVfVyIsIm9iamVjdGl2ZSIsInBvdyIsIm1pZHBvaW50IiwiYWJzIiwiY2FsY3VsYXRlV29ya2VyV2Fsa0F3YXkiLCJ3X1dBX3JhdyIsIndfV0FfY2xhbXBlZCIsImNhbGN1bGF0ZUVtcGxveWVyQ2VpbGluZyIsIndfRU1QX3JhdyIsImR5bmFtaWNNYXgiLCJ3X0VNUF9jbGFtcGVkIiwiY2FsY3VsYXRlWk9QQSIsIndfV0EiLCJ3X0VNUCIsInpvcGFfbWluIiwiem9wYV9tYXgiLCJ2YWxpZCIsImNhbGN1bGF0ZVdvcmtlckFuY2hvciIsIndfbmFzaCIsIndfYW5jaG9yX3JhdyIsImNhbGN1bGF0ZUFzcGlyYXRpb25CYW5kIiwid190b3BfcmF3Iiwid19mbG9vcl9yYXciLCJ0b3AiLCJmbG9vciIsImNhbGN1bGF0ZU5lZ290aWF0aW9uUGxhbiIsInBvbGljeVZhbHVlIiwiY3VzdG9tQXNrIiwicG9saWN5IiwiZmluZCIsInAiLCJ6b3BhIiwid19hbmNob3IiLCJhc3BpcmF0aW9uQmFuZCIsImNvZWZmaWNpZW50cyIsImNfbmFzaCIsImNfYW5jaG9yIiwiY19hc2siLCJ1bmRlZmluZWQiLCJlcnJvck1lc3NhZ2UiLCJnZW5lcmF0ZUNoYXJ0RGF0YSIsImRhdGEiLCJwdXNoIiwid2FnZSIsIm5hc2hQcm9kdWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/calculations.ts\n"));

/***/ })

});