"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/calculations.ts":
/*!*****************************!*\
  !*** ./lib/calculations.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: function() { return /* binding */ CONSTANTS; },\n/* harmony export */   POLICY_OPTIONS: function() { return /* binding */ POLICY_OPTIONS; },\n/* harmony export */   calculateAspirationBand: function() { return /* binding */ calculateAspirationBand; },\n/* harmony export */   calculateEmployerCeiling: function() { return /* binding */ calculateEmployerCeiling; },\n/* harmony export */   calculateNashSolution: function() { return /* binding */ calculateNashSolution; },\n/* harmony export */   calculateNegotiationPlan: function() { return /* binding */ calculateNegotiationPlan; },\n/* harmony export */   calculateUtilityFloors: function() { return /* binding */ calculateUtilityFloors; },\n/* harmony export */   calculateWorkerAnchor: function() { return /* binding */ calculateWorkerAnchor; },\n/* harmony export */   calculateWorkerWalkAway: function() { return /* binding */ calculateWorkerWalkAway; },\n/* harmony export */   calculateZOPA: function() { return /* binding */ calculateZOPA; },\n/* harmony export */   generateChartData: function() { return /* binding */ generateChartData; },\n/* harmony export */   utilityEmployer: function() { return /* binding */ utilityEmployer; },\n/* harmony export */   utilityWorker: function() { return /* binding */ utilityWorker; }\n/* harmony export */ });\n// 常量定义\nconst CONSTANTS = {\n    base: 2500,\n    w_E_ideal: 2500,\n    w_E_max: 8000,\n    w_W_min: 3500,\n    w_W_ideal: 8000,\n    feasible_min: 3500,\n    feasible_max: 8000,\n    grid_step: 1500,\n    employer_fallback_cost_money: 6000,\n    worker_fallback_income_money: 2490\n};\n// 政策情景映射\nconst POLICY_OPTIONS = [\n    {\n        label: \"一般保护（市场主导）\",\n        value: \"market\",\n        beta: 0.48\n    },\n    {\n        label: \"中度保护（偏向工人）\",\n        value: \"moderate\",\n        beta: 0.42\n    },\n    {\n        label: \"较强保护（集体谈判）\",\n        value: \"strong\",\n        beta: 0.35\n    },\n    {\n        label: \"强保护（强工会/强监管）\",\n        value: \"strongest\",\n        beta: 0.28\n    }\n];\n// 夹逼函数\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n// 四舍五入到最近的步长\nfunction roundToStep(value, step) {\n    return Math.round(value / step) * step;\n}\n// 计算Plan B映射的效用底线\nfunction calculateUtilityFloors(negotiationBreakdownCost, localMinimumWage, workerIdeal, workerMinimum) {\n    const { w_E_ideal } = CONSTANTS;\n    // 使用动态参数或默认值\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    const employer_fallback_cost = negotiationBreakdownCost || CONSTANTS.employer_fallback_cost_money;\n    const worker_fallback_income = localMinimumWage || CONSTANTS.worker_fallback_income_money;\n    const w_W_min = workerMinimum || CONSTANTS.w_W_min;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    const uE0_raw = 0.1 + 0.9 * (w_E_max - employer_fallback_cost) / (w_E_max - w_E_ideal);\n    const uW0_raw = 0.1 + 0.9 * (worker_fallback_income - w_W_min) / (w_W_ideal - w_W_min);\n    const u_E0 = clamp(uE0_raw, 0.1, 0.9);\n    const u_W0 = clamp(uW0_raw, 0.1, 0.9);\n    return {\n        u_E0,\n        u_W0\n    };\n}\n// 雇主效用函数\nfunction utilityEmployer(w, negotiationBreakdownCost) {\n    const { w_E_ideal } = CONSTANTS;\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    return clamp(0.1 + 0.9 * (w_E_max - w) / (w_E_max - w_E_ideal), 0, 1);\n}\n// 工人效用函数\nfunction utilityWorker(w, workerIdeal, workerMinimum) {\n    const w_W_min = workerMinimum || CONSTANTS.w_W_min;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    return clamp(0.1 + 0.9 * (w - w_W_min) / (w_W_ideal - w_W_min), 0, 1);\n}\n// Nash谈判解\nfunction calculateNashSolution(beta, u_E0, u_W0, negotiationBreakdownCost, workerIdeal, workerMinimum) {\n    const { feasible_min, grid_step } = CONSTANTS;\n    // 动态调整搜索上限，考虑用户输入的参数\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    const dynamicMax = Math.max(CONSTANTS.feasible_max, w_E_max, w_W_ideal);\n    let bestWage = feasible_min;\n    let maxObjective = -Infinity;\n    let hasValidSolution = false;\n    for(let w = feasible_min; w <= dynamicMax; w += grid_step){\n        const u_E = utilityEmployer(w, negotiationBreakdownCost);\n        const u_W = utilityWorker(w, workerIdeal, workerMinimum);\n        // 跳过无效区域\n        if (u_E <= u_E0 || u_W <= u_W0) continue;\n        hasValidSolution = true;\n        const objective = Math.pow(u_E - u_E0, beta) * Math.pow(u_W - u_W0, 1 - beta);\n        if (objective > maxObjective) {\n            maxObjective = objective;\n            bestWage = w;\n        } else if (objective === maxObjective) {\n            // 如果目标函数相等，选择更接近区间中点的\n            const midpoint = (feasible_min + dynamicMax) / 2;\n            if (Math.abs(w - midpoint) < Math.abs(bestWage - midpoint)) {\n                bestWage = w;\n            }\n        }\n    }\n    // 如果没有找到有效解，返回null\n    if (!hasValidSolution) {\n        return null;\n    }\n    return bestWage;\n}\n// 计算工人底线工资\nfunction calculateWorkerWalkAway(u_W0, workerIdeal, workerMinimum) {\n    const { feasible_min, feasible_max, grid_step } = CONSTANTS;\n    const w_W_min = workerMinimum || CONSTANTS.w_W_min;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    const w_WA_raw = w_W_min + (u_W0 - 0.1) / 0.9 * (w_W_ideal - w_W_min);\n    const w_WA_clamped = clamp(w_WA_raw, feasible_min, feasible_max);\n    return roundToStep(w_WA_clamped, grid_step);\n}\n// 计算雇主无差异上限\nfunction calculateEmployerCeiling(u_E0, negotiationBreakdownCost) {\n    const { w_E_ideal, feasible_min, grid_step } = CONSTANTS;\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    const w_EMP_raw = w_E_max - (u_E0 - 0.1) / 0.9 * (w_E_max - w_E_ideal);\n    // 雇主上限不应该超过谈判破裂成本，但可以低于feasible_max\n    const w_EMP_clamped = clamp(w_EMP_raw, feasible_min, w_E_max);\n    return roundToStep(w_EMP_clamped, grid_step);\n}\n// 计算ZOPA\nfunction calculateZOPA(w_WA, w_EMP) {\n    const { feasible_min } = CONSTANTS;\n    const zopa_min = Math.max(feasible_min, w_WA);\n    // 不限制ZOPA上限在固定的feasible_max，允许根据w_EMP动态调整\n    const zopa_max = w_EMP;\n    return {\n        min: zopa_min,\n        max: zopa_max,\n        valid: zopa_min <= zopa_max\n    };\n}\n// 计算工人锚点价格\nfunction calculateWorkerAnchor(w_nash, w_EMP) {\n    const { grid_step } = CONSTANTS;\n    const w_anchor_raw = Math.min(w_nash + 0.08 * (w_EMP - w_nash), w_EMP);\n    return roundToStep(w_anchor_raw, grid_step);\n}\n// 计算期望区间\nfunction calculateAspirationBand(w_nash, w_WA, w_EMP) {\n    const { grid_step } = CONSTANTS;\n    const w_top_raw = Math.min(w_nash + 0.15 * (w_EMP - w_WA), w_EMP);\n    const w_floor_raw = Math.max(w_WA, w_nash - 0.05 * (w_nash - w_WA));\n    return {\n        top: roundToStep(w_top_raw, grid_step),\n        floor: roundToStep(w_floor_raw, grid_step)\n    };\n}\n// 主计算函数\nfunction calculateNegotiationPlan(policyValue, customAsk, negotiationBreakdownCost, localMinimumWage, workerIdeal, workerMinimum) {\n    const policy = POLICY_OPTIONS.find((p)=>p.value === policyValue) || POLICY_OPTIONS[2];\n    const beta = policy.beta;\n    const { u_E0, u_W0 } = calculateUtilityFloors(negotiationBreakdownCost, localMinimumWage, workerIdeal, workerMinimum);\n    const w_WA = calculateWorkerWalkAway(u_W0, workerIdeal, workerMinimum);\n    const w_EMP = calculateEmployerCeiling(u_E0, negotiationBreakdownCost);\n    const zopa = calculateZOPA(w_WA, w_EMP);\n    const w_nash = calculateNashSolution(beta, u_E0, u_W0, negotiationBreakdownCost, workerIdeal, workerMinimum);\n    // 检查是否有Nash解\n    if (w_nash === null) {\n        return {\n            policy,\n            beta,\n            u_E0,\n            u_W0,\n            w_nash: null,\n            w_anchor: null,\n            w_WA,\n            w_EMP,\n            zopa,\n            aspirationBand: null,\n            coefficients: {\n                c_nash: null,\n                c_anchor: null,\n                c_ask: customAsk ? customAsk / CONSTANTS.base : undefined\n            },\n            customAsk,\n            hasValidSolution: false,\n            errorMessage: \"工资期望过高，雇主效用不足，Nash解不存在\"\n        };\n    }\n    const w_anchor = calculateWorkerAnchor(w_nash, w_EMP);\n    const aspirationBand = calculateAspirationBand(w_nash, w_WA, w_EMP);\n    // 转换为加班系数\n    const c_nash = w_nash / CONSTANTS.base;\n    const c_anchor = w_anchor / CONSTANTS.base;\n    const c_ask = customAsk ? customAsk / CONSTANTS.base : undefined;\n    return {\n        policy,\n        beta,\n        u_E0,\n        u_W0,\n        w_nash,\n        w_anchor,\n        w_WA,\n        w_EMP,\n        zopa,\n        aspirationBand,\n        coefficients: {\n            c_nash,\n            c_anchor,\n            c_ask\n        },\n        customAsk,\n        hasValidSolution: true\n    };\n}\n// 生成图表数据\nfunction generateChartData(u_E0, u_W0, negotiationBreakdownCost, workerIdeal, workerMinimum) {\n    const { grid_step } = CONSTANTS;\n    // 从工人底线开始显示图表\n    const w_W_min = workerMinimum || CONSTANTS.w_W_min;\n    const chartMin = w_W_min;\n    // 动态调整图表数据范围\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    const dynamicMax = Math.max(CONSTANTS.feasible_max, w_E_max, w_W_ideal);\n    const data = [];\n    for(let w = chartMin; w <= dynamicMax; w += grid_step){\n        const u_E = utilityEmployer(w, negotiationBreakdownCost);\n        const u_W = utilityWorker(w, workerIdeal, workerMinimum);\n        data.push({\n            wage: w,\n            u_E,\n            u_W,\n            nashProduct: u_E > u_E0 && u_W > u_W0 ? (u_E - u_E0) * (u_W - u_W0) : 0\n        });\n    }\n    return data;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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a0QsVUFBVWxELEtBQUtHLFlBQVlILEtBQUsxQixVQUFXO1FBQ3RELE1BQU1rQyxNQUFNVCxnQkFBZ0JDLEdBQUdYO1FBQy9CLE1BQU1vQixNQUFNUixjQUFjRCxHQUFHVCxhQUFhQztRQUUxQzJELEtBQUtDLElBQUksQ0FBQztZQUNSQyxNQUFNckQ7WUFDTlE7WUFDQUM7WUFDQTZDLGFBQWEsTUFBT3pELFFBQVFZLE1BQU1YLE9BQVEsQ0FBQ1UsTUFBTVgsSUFBRyxJQUFNWSxDQUFBQSxNQUFNWCxJQUFHLElBQUs7UUFDMUU7SUFDRjtJQUVBLE9BQU9xRDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9jYWxjdWxhdGlvbnMudHM/M2Y3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyDluLjph4/lrprkuYlcbmV4cG9ydCBjb25zdCBDT05TVEFOVFMgPSB7XG4gIGJhc2U6IDI1MDAsXG4gIHdfRV9pZGVhbDogMjUwMCxcbiAgd19FX21heDogODAwMCxcbiAgd19XX21pbjogMzUwMCxcbiAgd19XX2lkZWFsOiA4MDAwLFxuICBmZWFzaWJsZV9taW46IDM1MDAsXG4gIGZlYXNpYmxlX21heDogODAwMCxcbiAgZ3JpZF9zdGVwOiAxNTAwLFxuICBlbXBsb3llcl9mYWxsYmFja19jb3N0X21vbmV5OiA2MDAwLFxuICB3b3JrZXJfZmFsbGJhY2tfaW5jb21lX21vbmV5OiAyNDkwXG59O1xuXG4vLyDmlL/nrZbmg4Xmma/mmKDlsIRcbmV4cG9ydCBjb25zdCBQT0xJQ1lfT1BUSU9OUyA9IFtcbiAgeyBsYWJlbDogXCLkuIDoiKzkv53miqTvvIjluILlnLrkuLvlr7zvvIlcIiwgdmFsdWU6IFwibWFya2V0XCIsIGJldGE6IDAuNDggfSxcbiAgeyBsYWJlbDogXCLkuK3luqbkv53miqTvvIjlgY/lkJHlt6XkurrvvIlcIiwgdmFsdWU6IFwibW9kZXJhdGVcIiwgYmV0YTogMC40MiB9LFxuICB7IGxhYmVsOiBcIui+g+W8uuS/neaKpO+8iOmbhuS9k+iwiOWIpO+8iVwiLCB2YWx1ZTogXCJzdHJvbmdcIiwgYmV0YTogMC4zNSB9LFxuICB7IGxhYmVsOiBcIuW8uuS/neaKpO+8iOW8uuW3peS8mi/lvLrnm5HnrqHvvIlcIiwgdmFsdWU6IFwic3Ryb25nZXN0XCIsIGJldGE6IDAuMjggfVxuXTtcblxuLy8g5aS56YC85Ye95pWwXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5cbi8vIOWbm+iIjeS6lOWFpeWIsOacgOi/keeahOatpemVv1xuZnVuY3Rpb24gcm91bmRUb1N0ZXAodmFsdWU6IG51bWJlciwgc3RlcDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgLyBzdGVwKSAqIHN0ZXA7XG59XG5cbi8vIOiuoeeul1BsYW4gQuaYoOWwhOeahOaViOeUqOW6lee6v1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVV0aWxpdHlGbG9vcnMobmVnb3RpYXRpb25CcmVha2Rvd25Db3N0PzogbnVtYmVyLCBsb2NhbE1pbmltdW1XYWdlPzogbnVtYmVyLCB3b3JrZXJJZGVhbD86IG51bWJlciwgd29ya2VyTWluaW11bT86IG51bWJlcikge1xuICBjb25zdCB7IHdfRV9pZGVhbCB9ID0gQ09OU1RBTlRTO1xuICBcbiAgLy8g5L2/55So5Yqo5oCB5Y+C5pWw5oiW6buY6K6k5YC8XG4gIGNvbnN0IHdfRV9tYXggPSBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QgfHwgQ09OU1RBTlRTLndfRV9tYXg7XG4gIGNvbnN0IGVtcGxveWVyX2ZhbGxiYWNrX2Nvc3QgPSBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QgfHwgQ09OU1RBTlRTLmVtcGxveWVyX2ZhbGxiYWNrX2Nvc3RfbW9uZXk7XG4gIGNvbnN0IHdvcmtlcl9mYWxsYmFja19pbmNvbWUgPSBsb2NhbE1pbmltdW1XYWdlIHx8IENPTlNUQU5UUy53b3JrZXJfZmFsbGJhY2tfaW5jb21lX21vbmV5O1xuICBjb25zdCB3X1dfbWluID0gd29ya2VyTWluaW11bSB8fCBDT05TVEFOVFMud19XX21pbjtcbiAgY29uc3Qgd19XX2lkZWFsID0gd29ya2VySWRlYWwgfHwgQ09OU1RBTlRTLndfV19pZGVhbDtcbiAgXG4gIGNvbnN0IHVFMF9yYXcgPSAwLjEgKyAwLjkgKiAod19FX21heCAtIGVtcGxveWVyX2ZhbGxiYWNrX2Nvc3QpIC8gKHdfRV9tYXggLSB3X0VfaWRlYWwpO1xuICBjb25zdCB1VzBfcmF3ID0gMC4xICsgMC45ICogKHdvcmtlcl9mYWxsYmFja19pbmNvbWUgLSB3X1dfbWluKSAvICh3X1dfaWRlYWwgLSB3X1dfbWluKTtcbiAgXG4gIGNvbnN0IHVfRTAgPSBjbGFtcCh1RTBfcmF3LCAwLjEsIDAuOSk7XG4gIGNvbnN0IHVfVzAgPSBjbGFtcCh1VzBfcmF3LCAwLjEsIDAuOSk7XG4gIFxuICByZXR1cm4geyB1X0UwLCB1X1cwIH07XG59XG5cbi8vIOmbh+S4u+aViOeUqOWHveaVsFxuZXhwb3J0IGZ1bmN0aW9uIHV0aWxpdHlFbXBsb3llcih3OiBudW1iZXIsIG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdD86IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHsgd19FX2lkZWFsIH0gPSBDT05TVEFOVFM7XG4gIGNvbnN0IHdfRV9tYXggPSBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QgfHwgQ09OU1RBTlRTLndfRV9tYXg7XG4gIHJldHVybiBjbGFtcCgwLjEgKyAwLjkgKiAod19FX21heCAtIHcpIC8gKHdfRV9tYXggLSB3X0VfaWRlYWwpLCAwLCAxKTtcbn1cblxuLy8g5bel5Lq65pWI55So5Ye95pWwXG5leHBvcnQgZnVuY3Rpb24gdXRpbGl0eVdvcmtlcih3OiBudW1iZXIsIHdvcmtlcklkZWFsPzogbnVtYmVyLCB3b3JrZXJNaW5pbXVtPzogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3Qgd19XX21pbiA9IHdvcmtlck1pbmltdW0gfHwgQ09OU1RBTlRTLndfV19taW47XG4gIGNvbnN0IHdfV19pZGVhbCA9IHdvcmtlcklkZWFsIHx8IENPTlNUQU5UUy53X1dfaWRlYWw7XG4gIHJldHVybiBjbGFtcCgwLjEgKyAwLjkgKiAodyAtIHdfV19taW4pIC8gKHdfV19pZGVhbCAtIHdfV19taW4pLCAwLCAxKTtcbn1cblxuLy8gTmFzaOiwiOWIpOino1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU5hc2hTb2x1dGlvbihiZXRhOiBudW1iZXIsIHVfRTA6IG51bWJlciwgdV9XMDogbnVtYmVyLCBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3Q/OiBudW1iZXIsIHdvcmtlcklkZWFsPzogbnVtYmVyLCB3b3JrZXJNaW5pbXVtPzogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IHsgZmVhc2libGVfbWluLCBncmlkX3N0ZXAgfSA9IENPTlNUQU5UUztcbiAgLy8g5Yqo5oCB6LCD5pW05pCc57Si5LiK6ZmQ77yM6ICD6JmR55So5oi36L6T5YWl55qE5Y+C5pWwXG4gIGNvbnN0IHdfRV9tYXggPSBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QgfHwgQ09OU1RBTlRTLndfRV9tYXg7XG4gIGNvbnN0IHdfV19pZGVhbCA9IHdvcmtlcklkZWFsIHx8IENPTlNUQU5UUy53X1dfaWRlYWw7XG4gIGNvbnN0IGR5bmFtaWNNYXggPSBNYXRoLm1heChDT05TVEFOVFMuZmVhc2libGVfbWF4LCB3X0VfbWF4LCB3X1dfaWRlYWwpO1xuICBcbiAgbGV0IGJlc3RXYWdlID0gZmVhc2libGVfbWluO1xuICBsZXQgbWF4T2JqZWN0aXZlID0gLUluZmluaXR5O1xuICBsZXQgaGFzVmFsaWRTb2x1dGlvbiA9IGZhbHNlO1xuICBcbiAgZm9yIChsZXQgdyA9IGZlYXNpYmxlX21pbjsgdyA8PSBkeW5hbWljTWF4OyB3ICs9IGdyaWRfc3RlcCkge1xuICAgIGNvbnN0IHVfRSA9IHV0aWxpdHlFbXBsb3llcih3LCBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QpO1xuICAgIGNvbnN0IHVfVyA9IHV0aWxpdHlXb3JrZXIodywgd29ya2VySWRlYWwsIHdvcmtlck1pbmltdW0pO1xuICAgIFxuICAgIC8vIOi3s+i/h+aXoOaViOWMuuWfn1xuICAgIGlmICh1X0UgPD0gdV9FMCB8fCB1X1cgPD0gdV9XMCkgY29udGludWU7XG4gICAgXG4gICAgaGFzVmFsaWRTb2x1dGlvbiA9IHRydWU7XG4gICAgY29uc3Qgb2JqZWN0aXZlID0gTWF0aC5wb3codV9FIC0gdV9FMCwgYmV0YSkgKiBNYXRoLnBvdyh1X1cgLSB1X1cwLCAxIC0gYmV0YSk7XG4gICAgXG4gICAgaWYgKG9iamVjdGl2ZSA+IG1heE9iamVjdGl2ZSkge1xuICAgICAgbWF4T2JqZWN0aXZlID0gb2JqZWN0aXZlO1xuICAgICAgYmVzdFdhZ2UgPSB3O1xuICAgIH0gZWxzZSBpZiAob2JqZWN0aXZlID09PSBtYXhPYmplY3RpdmUpIHtcbiAgICAgIC8vIOWmguaenOebruagh+WHveaVsOebuOetie+8jOmAieaLqeabtOaOpei/keWMuumXtOS4reeCueeahFxuICAgICAgY29uc3QgbWlkcG9pbnQgPSAoZmVhc2libGVfbWluICsgZHluYW1pY01heCkgLyAyO1xuICAgICAgaWYgKE1hdGguYWJzKHcgLSBtaWRwb2ludCkgPCBNYXRoLmFicyhiZXN0V2FnZSAtIG1pZHBvaW50KSkge1xuICAgICAgICBiZXN0V2FnZSA9IHc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyDlpoLmnpzmsqHmnInmib7liLDmnInmlYjop6PvvIzov5Tlm55udWxsXG4gIGlmICghaGFzVmFsaWRTb2x1dGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIFxuICByZXR1cm4gYmVzdFdhZ2U7XG59XG5cbi8vIOiuoeeul+W3peS6uuW6lee6v+W3pei1hFxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVdvcmtlcldhbGtBd2F5KHVfVzA6IG51bWJlciwgd29ya2VySWRlYWw/OiBudW1iZXIsIHdvcmtlck1pbmltdW0/OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB7IGZlYXNpYmxlX21pbiwgZmVhc2libGVfbWF4LCBncmlkX3N0ZXAgfSA9IENPTlNUQU5UUztcbiAgY29uc3Qgd19XX21pbiA9IHdvcmtlck1pbmltdW0gfHwgQ09OU1RBTlRTLndfV19taW47XG4gIGNvbnN0IHdfV19pZGVhbCA9IHdvcmtlcklkZWFsIHx8IENPTlNUQU5UUy53X1dfaWRlYWw7XG4gIFxuICBjb25zdCB3X1dBX3JhdyA9IHdfV19taW4gKyAoKHVfVzAgLSAwLjEpIC8gMC45KSAqICh3X1dfaWRlYWwgLSB3X1dfbWluKTtcbiAgY29uc3Qgd19XQV9jbGFtcGVkID0gY2xhbXAod19XQV9yYXcsIGZlYXNpYmxlX21pbiwgZmVhc2libGVfbWF4KTtcbiAgXG4gIHJldHVybiByb3VuZFRvU3RlcCh3X1dBX2NsYW1wZWQsIGdyaWRfc3RlcCk7XG59XG5cbi8vIOiuoeeul+mbh+S4u+aXoOW3ruW8guS4iumZkFxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUVtcGxveWVyQ2VpbGluZyh1X0UwOiBudW1iZXIsIG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdD86IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHsgd19FX2lkZWFsLCBmZWFzaWJsZV9taW4sIGdyaWRfc3RlcCB9ID0gQ09OU1RBTlRTO1xuICBjb25zdCB3X0VfbWF4ID0gbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0IHx8IENPTlNUQU5UUy53X0VfbWF4O1xuICBcbiAgY29uc3Qgd19FTVBfcmF3ID0gd19FX21heCAtICgodV9FMCAtIDAuMSkgLyAwLjkpICogKHdfRV9tYXggLSB3X0VfaWRlYWwpO1xuICAvLyDpm4fkuLvkuIrpmZDkuI3lupTor6XotoXov4fosIjliKTnoLToo4LmiJDmnKzvvIzkvYblj6/ku6XkvY7kuo5mZWFzaWJsZV9tYXhcbiAgY29uc3Qgd19FTVBfY2xhbXBlZCA9IGNsYW1wKHdfRU1QX3JhdywgZmVhc2libGVfbWluLCB3X0VfbWF4KTtcbiAgXG4gIHJldHVybiByb3VuZFRvU3RlcCh3X0VNUF9jbGFtcGVkLCBncmlkX3N0ZXApO1xufVxuXG4vLyDorqHnrpdaT1BBXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlWk9QQSh3X1dBOiBudW1iZXIsIHdfRU1QOiBudW1iZXIpOiB7IG1pbjogbnVtYmVyOyBtYXg6IG51bWJlcjsgdmFsaWQ6IGJvb2xlYW4gfSB7XG4gIGNvbnN0IHsgZmVhc2libGVfbWluIH0gPSBDT05TVEFOVFM7XG4gIFxuICBjb25zdCB6b3BhX21pbiA9IE1hdGgubWF4KGZlYXNpYmxlX21pbiwgd19XQSk7XG4gIC8vIOS4jemZkOWItlpPUEHkuIrpmZDlnKjlm7rlrprnmoRmZWFzaWJsZV9tYXjvvIzlhYHorrjmoLnmja53X0VNUOWKqOaAgeiwg+aVtFxuICBjb25zdCB6b3BhX21heCA9IHdfRU1QO1xuICBcbiAgcmV0dXJuIHtcbiAgICBtaW46IHpvcGFfbWluLFxuICAgIG1heDogem9wYV9tYXgsXG4gICAgdmFsaWQ6IHpvcGFfbWluIDw9IHpvcGFfbWF4XG4gIH07XG59XG5cbi8vIOiuoeeul+W3peS6uumUmueCueS7t+agvFxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVdvcmtlckFuY2hvcih3X25hc2g6IG51bWJlciwgd19FTVA6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHsgZ3JpZF9zdGVwIH0gPSBDT05TVEFOVFM7XG4gIFxuICBjb25zdCB3X2FuY2hvcl9yYXcgPSBNYXRoLm1pbih3X25hc2ggKyAwLjA4ICogKHdfRU1QIC0gd19uYXNoKSwgd19FTVApO1xuICByZXR1cm4gcm91bmRUb1N0ZXAod19hbmNob3JfcmF3LCBncmlkX3N0ZXApO1xufVxuXG4vLyDorqHnrpfmnJ/mnJvljLrpl7RcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVBc3BpcmF0aW9uQmFuZCh3X25hc2g6IG51bWJlciwgd19XQTogbnVtYmVyLCB3X0VNUDogbnVtYmVyKTogeyB0b3A6IG51bWJlcjsgZmxvb3I6IG51bWJlciB9IHtcbiAgY29uc3QgeyBncmlkX3N0ZXAgfSA9IENPTlNUQU5UUztcbiAgXG4gIGNvbnN0IHdfdG9wX3JhdyA9IE1hdGgubWluKHdfbmFzaCArIDAuMTUgKiAod19FTVAgLSB3X1dBKSwgd19FTVApO1xuICBjb25zdCB3X2Zsb29yX3JhdyA9IE1hdGgubWF4KHdfV0EsIHdfbmFzaCAtIDAuMDUgKiAod19uYXNoIC0gd19XQSkpO1xuICBcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHJvdW5kVG9TdGVwKHdfdG9wX3JhdywgZ3JpZF9zdGVwKSxcbiAgICBmbG9vcjogcm91bmRUb1N0ZXAod19mbG9vcl9yYXcsIGdyaWRfc3RlcClcbiAgfTtcbn1cblxuLy8g5Li76K6h566X5Ye95pWwXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTmVnb3RpYXRpb25QbGFuKHBvbGljeVZhbHVlOiBzdHJpbmcsIGN1c3RvbUFzaz86IG51bWJlciwgbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0PzogbnVtYmVyLCBsb2NhbE1pbmltdW1XYWdlPzogbnVtYmVyLCB3b3JrZXJJZGVhbD86IG51bWJlciwgd29ya2VyTWluaW11bT86IG51bWJlcikge1xuICBjb25zdCBwb2xpY3kgPSBQT0xJQ1lfT1BUSU9OUy5maW5kKHAgPT4gcC52YWx1ZSA9PT0gcG9saWN5VmFsdWUpIHx8IFBPTElDWV9PUFRJT05TWzJdO1xuICBjb25zdCBiZXRhID0gcG9saWN5LmJldGE7XG4gIFxuICBjb25zdCB7IHVfRTAsIHVfVzAgfSA9IGNhbGN1bGF0ZVV0aWxpdHlGbG9vcnMobmVnb3RpYXRpb25CcmVha2Rvd25Db3N0LCBsb2NhbE1pbmltdW1XYWdlLCB3b3JrZXJJZGVhbCwgd29ya2VyTWluaW11bSk7XG4gIFxuICBjb25zdCB3X1dBID0gY2FsY3VsYXRlV29ya2VyV2Fsa0F3YXkodV9XMCwgd29ya2VySWRlYWwsIHdvcmtlck1pbmltdW0pO1xuICBjb25zdCB3X0VNUCA9IGNhbGN1bGF0ZUVtcGxveWVyQ2VpbGluZyh1X0UwLCBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QpO1xuICBjb25zdCB6b3BhID0gY2FsY3VsYXRlWk9QQSh3X1dBLCB3X0VNUCk7XG4gIFxuICBjb25zdCB3X25hc2ggPSBjYWxjdWxhdGVOYXNoU29sdXRpb24oYmV0YSwgdV9FMCwgdV9XMCwgbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0LCB3b3JrZXJJZGVhbCwgd29ya2VyTWluaW11bSk7XG4gIFxuICAvLyDmo4Dmn6XmmK/lkKbmnIlOYXNo6KejXG4gIGlmICh3X25hc2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9saWN5LFxuICAgICAgYmV0YSxcbiAgICAgIHVfRTAsXG4gICAgICB1X1cwLFxuICAgICAgd19uYXNoOiBudWxsLFxuICAgICAgd19hbmNob3I6IG51bGwsXG4gICAgICB3X1dBLFxuICAgICAgd19FTVAsXG4gICAgICB6b3BhLFxuICAgICAgYXNwaXJhdGlvbkJhbmQ6IG51bGwsXG4gICAgICBjb2VmZmljaWVudHM6IHtcbiAgICAgICAgY19uYXNoOiBudWxsLFxuICAgICAgICBjX2FuY2hvcjogbnVsbCxcbiAgICAgICAgY19hc2s6IGN1c3RvbUFzayA/IGN1c3RvbUFzayAvIENPTlNUQU5UUy5iYXNlIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgY3VzdG9tQXNrLFxuICAgICAgaGFzVmFsaWRTb2x1dGlvbjogZmFsc2UsXG4gICAgICBlcnJvck1lc3NhZ2U6IFwi5bel6LWE5pyf5pyb6L+H6auY77yM6ZuH5Li75pWI55So5LiN6Laz77yMTmFzaOino+S4jeWtmOWcqFwiXG4gICAgfTtcbiAgfVxuICBcbiAgY29uc3Qgd19hbmNob3IgPSBjYWxjdWxhdGVXb3JrZXJBbmNob3Iod19uYXNoLCB3X0VNUCk7XG4gIGNvbnN0IGFzcGlyYXRpb25CYW5kID0gY2FsY3VsYXRlQXNwaXJhdGlvbkJhbmQod19uYXNoLCB3X1dBLCB3X0VNUCk7XG4gIFxuICAvLyDovazmjaLkuLrliqDnj63ns7vmlbBcbiAgY29uc3QgY19uYXNoID0gd19uYXNoIC8gQ09OU1RBTlRTLmJhc2U7XG4gIGNvbnN0IGNfYW5jaG9yID0gd19hbmNob3IgLyBDT05TVEFOVFMuYmFzZTtcbiAgY29uc3QgY19hc2sgPSBjdXN0b21Bc2sgPyBjdXN0b21Bc2sgLyBDT05TVEFOVFMuYmFzZSA6IHVuZGVmaW5lZDtcbiAgXG4gIHJldHVybiB7XG4gICAgcG9saWN5LFxuICAgIGJldGEsXG4gICAgdV9FMCxcbiAgICB1X1cwLFxuICAgIHdfbmFzaCxcbiAgICB3X2FuY2hvcixcbiAgICB3X1dBLFxuICAgIHdfRU1QLFxuICAgIHpvcGEsXG4gICAgYXNwaXJhdGlvbkJhbmQsXG4gICAgY29lZmZpY2llbnRzOiB7XG4gICAgICBjX25hc2gsXG4gICAgICBjX2FuY2hvcixcbiAgICAgIGNfYXNrXG4gICAgfSxcbiAgICBjdXN0b21Bc2ssXG4gICAgaGFzVmFsaWRTb2x1dGlvbjogdHJ1ZVxuICB9O1xufVxuXG4vLyDlm77ooajmlbDmja7nsbvlnotcbmV4cG9ydCBpbnRlcmZhY2UgQ2hhcnREYXRhUG9pbnQge1xuICB3YWdlOiBudW1iZXI7XG4gIHVfRTogbnVtYmVyO1xuICB1X1c6IG51bWJlcjtcbiAgbmFzaFByb2R1Y3Q6IG51bWJlcjtcbn1cblxuLy8g55Sf5oiQ5Zu+6KGo5pWw5o2uXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDaGFydERhdGEodV9FMDogbnVtYmVyLCB1X1cwOiBudW1iZXIsIG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdD86IG51bWJlciwgd29ya2VySWRlYWw/OiBudW1iZXIsIHdvcmtlck1pbmltdW0/OiBudW1iZXIpOiBDaGFydERhdGFQb2ludFtdIHtcbiAgY29uc3QgeyBncmlkX3N0ZXAgfSA9IENPTlNUQU5UUztcbiAgLy8g5LuO5bel5Lq65bqV57q/5byA5aeL5pi+56S65Zu+6KGoXG4gIGNvbnN0IHdfV19taW4gPSB3b3JrZXJNaW5pbXVtIHx8IENPTlNUQU5UUy53X1dfbWluO1xuICBjb25zdCBjaGFydE1pbiA9IHdfV19taW47XG4gIFxuICAvLyDliqjmgIHosIPmlbTlm77ooajmlbDmja7ojIPlm7RcbiAgY29uc3Qgd19FX21heCA9IG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdCB8fCBDT05TVEFOVFMud19FX21heDtcbiAgY29uc3Qgd19XX2lkZWFsID0gd29ya2VySWRlYWwgfHwgQ09OU1RBTlRTLndfV19pZGVhbDtcbiAgY29uc3QgZHluYW1pY01heCA9IE1hdGgubWF4KENPTlNUQU5UUy5mZWFzaWJsZV9tYXgsIHdfRV9tYXgsIHdfV19pZGVhbCk7XG4gIGNvbnN0IGRhdGE6IENoYXJ0RGF0YVBvaW50W10gPSBbXTtcbiAgXG4gIGZvciAobGV0IHcgPSBjaGFydE1pbjsgdyA8PSBkeW5hbWljTWF4OyB3ICs9IGdyaWRfc3RlcCkge1xuICAgIGNvbnN0IHVfRSA9IHV0aWxpdHlFbXBsb3llcih3LCBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QpO1xuICAgIGNvbnN0IHVfVyA9IHV0aWxpdHlXb3JrZXIodywgd29ya2VySWRlYWwsIHdvcmtlck1pbmltdW0pO1xuICAgIFxuICAgIGRhdGEucHVzaCh7XG4gICAgICB3YWdlOiB3LFxuICAgICAgdV9FLFxuICAgICAgdV9XLFxuICAgICAgbmFzaFByb2R1Y3Q6ICh1X0UgPiB1X0UwICYmIHVfVyA+IHVfVzApID8gKHVfRSAtIHVfRTApICogKHVfVyAtIHVfVzApIDogMFxuICAgIH0pO1xuICB9XG4gIFxuICByZXR1cm4gZGF0YTtcbn0iXSwibmFtZXMiOlsiQ09OU1RBTlRTIiwiYmFzZSIsIndfRV9pZGVhbCIsIndfRV9tYXgiLCJ3X1dfbWluIiwid19XX2lkZWFsIiwiZmVhc2libGVfbWluIiwiZmVhc2libGVfbWF4IiwiZ3JpZF9zdGVwIiwiZW1wbG95ZXJfZmFsbGJhY2tfY29zdF9tb25leSIsIndvcmtlcl9mYWxsYmFja19pbmNvbWVfbW9uZXkiLCJQT0xJQ1lfT1BUSU9OUyIsImxhYmVsIiwidmFsdWUiLCJiZXRhIiwiY2xhbXAiLCJtaW4iLCJtYXgiLCJNYXRoIiwicm91bmRUb1N0ZXAiLCJzdGVwIiwicm91bmQiLCJjYWxjdWxhdGVVdGlsaXR5Rmxvb3JzIiwibmVnb3RpYXRpb25CcmVha2Rvd25Db3N0IiwibG9jYWxNaW5pbXVtV2FnZSIsIndvcmtlcklkZWFsIiwid29ya2VyTWluaW11bSIsImVtcGxveWVyX2ZhbGxiYWNrX2Nvc3QiLCJ3b3JrZXJfZmFsbGJhY2tfaW5jb21lIiwidUUwX3JhdyIsInVXMF9yYXciLCJ1X0UwIiwidV9XMCIsInV0aWxpdHlFbXBsb3llciIsInciLCJ1dGlsaXR5V29ya2VyIiwiY2FsY3VsYXRlTmFzaFNvbHV0aW9uIiwiZHluYW1pY01heCIsImJlc3RXYWdlIiwibWF4T2JqZWN0aXZlIiwiSW5maW5pdHkiLCJoYXNWYWxpZFNvbHV0aW9uIiwidV9FIiwidV9XIiwib2JqZWN0aXZlIiwicG93IiwibWlkcG9pbnQiLCJhYnMiLCJjYWxjdWxhdGVXb3JrZXJXYWxrQXdheSIsIndfV0FfcmF3Iiwid19XQV9jbGFtcGVkIiwiY2FsY3VsYXRlRW1wbG95ZXJDZWlsaW5nIiwid19FTVBfcmF3Iiwid19FTVBfY2xhbXBlZCIsImNhbGN1bGF0ZVpPUEEiLCJ3X1dBIiwid19FTVAiLCJ6b3BhX21pbiIsInpvcGFfbWF4IiwidmFsaWQiLCJjYWxjdWxhdGVXb3JrZXJBbmNob3IiLCJ3X25hc2giLCJ3X2FuY2hvcl9yYXciLCJjYWxjdWxhdGVBc3BpcmF0aW9uQmFuZCIsIndfdG9wX3JhdyIsIndfZmxvb3JfcmF3IiwidG9wIiwiZmxvb3IiLCJjYWxjdWxhdGVOZWdvdGlhdGlvblBsYW4iLCJwb2xpY3lWYWx1ZSIsImN1c3RvbUFzayIsInBvbGljeSIsImZpbmQiLCJwIiwiem9wYSIsIndfYW5jaG9yIiwiYXNwaXJhdGlvbkJhbmQiLCJjb2VmZmljaWVudHMiLCJjX25hc2giLCJjX2FuY2hvciIsImNfYXNrIiwidW5kZWZpbmVkIiwiZXJyb3JNZXNzYWdlIiwiZ2VuZXJhdGVDaGFydERhdGEiLCJjaGFydE1pbiIsImRhdGEiLCJwdXNoIiwid2FnZSIsIm5hc2hQcm9kdWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/calculations.ts\n"));

/***/ })

});