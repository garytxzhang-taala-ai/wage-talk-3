"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/calculations.ts":
/*!*****************************!*\
  !*** ./lib/calculations.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: function() { return /* binding */ CONSTANTS; },\n/* harmony export */   POLICY_OPTIONS: function() { return /* binding */ POLICY_OPTIONS; },\n/* harmony export */   calculateAspirationBand: function() { return /* binding */ calculateAspirationBand; },\n/* harmony export */   calculateEmployerCeiling: function() { return /* binding */ calculateEmployerCeiling; },\n/* harmony export */   calculateNashSolution: function() { return /* binding */ calculateNashSolution; },\n/* harmony export */   calculateNegotiationPlan: function() { return /* binding */ calculateNegotiationPlan; },\n/* harmony export */   calculateUtilityFloors: function() { return /* binding */ calculateUtilityFloors; },\n/* harmony export */   calculateWorkerAnchor: function() { return /* binding */ calculateWorkerAnchor; },\n/* harmony export */   calculateWorkerWalkAway: function() { return /* binding */ calculateWorkerWalkAway; },\n/* harmony export */   calculateZOPA: function() { return /* binding */ calculateZOPA; },\n/* harmony export */   generateChartData: function() { return /* binding */ generateChartData; },\n/* harmony export */   utilityEmployer: function() { return /* binding */ utilityEmployer; },\n/* harmony export */   utilityWorker: function() { return /* binding */ utilityWorker; }\n/* harmony export */ });\n// 常量定义\nconst CONSTANTS = {\n    base: 2500,\n    w_E_ideal: 2500,\n    w_E_max: 8000,\n    w_W_min: 3500,\n    w_W_ideal: 8000,\n    feasible_min: 3500,\n    feasible_max: 8000,\n    grid_step: 50,\n    employer_fallback_cost_money: 6000,\n    worker_fallback_income_money: 2490\n};\n// 政策情景映射\nconst POLICY_OPTIONS = [\n    {\n        label: \"一般保护（市场主导）\",\n        value: \"market\",\n        beta: 0.48\n    },\n    {\n        label: \"中度保护（偏向工人）\",\n        value: \"moderate\",\n        beta: 0.42\n    },\n    {\n        label: \"较强保护（集体谈判）\",\n        value: \"strong\",\n        beta: 0.35\n    },\n    {\n        label: \"强保护（强工会/强监管）\",\n        value: \"strongest\",\n        beta: 0.28\n    }\n];\n// 夹逼函数\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n// 四舍五入到最近的步长\nfunction roundToStep(value, step) {\n    return Math.round(value / step) * step;\n}\n// 计算Plan B映射的效用底线\nfunction calculateUtilityFloors(negotiationBreakdownCost, localMinimumWage, workerIdeal, workerMinimum) {\n    const { w_E_ideal } = CONSTANTS;\n    // 使用动态参数或默认值\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    const employer_fallback_cost = negotiationBreakdownCost || CONSTANTS.employer_fallback_cost_money;\n    const worker_fallback_income = localMinimumWage || CONSTANTS.worker_fallback_income_money;\n    const w_W_min = workerMinimum || CONSTANTS.w_W_min;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    const uE0_raw = 0.1 + 0.9 * (w_E_max - employer_fallback_cost) / (w_E_max - w_E_ideal);\n    const uW0_raw = 0.1 + 0.9 * (worker_fallback_income - w_W_min) / (w_W_ideal - w_W_min);\n    const u_E0 = clamp(uE0_raw, 0.1, 0.9);\n    const u_W0 = clamp(uW0_raw, 0.1, 0.9);\n    return {\n        u_E0,\n        u_W0\n    };\n}\n// 雇主效用函数\nfunction utilityEmployer(w, negotiationBreakdownCost) {\n    const { w_E_ideal } = CONSTANTS;\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    return clamp(0.1 + 0.9 * (w_E_max - w) / (w_E_max - w_E_ideal), 0, 1);\n}\n// 工人效用函数\nfunction utilityWorker(w, workerIdeal, workerMinimum) {\n    const w_W_min = workerMinimum || CONSTANTS.w_W_min;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    return clamp(0.1 + 0.9 * (w - w_W_min) / (w_W_ideal - w_W_min), 0, 1);\n}\n// Nash谈判解\nfunction calculateNashSolution(beta, u_E0, u_W0, negotiationBreakdownCost, workerIdeal, workerMinimum) {\n    const { feasible_min, grid_step } = CONSTANTS;\n    // 动态调整搜索上限，考虑用户输入的参数\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    const dynamicMax = Math.max(CONSTANTS.feasible_max, w_E_max, w_W_ideal);\n    let bestWage = feasible_min;\n    let maxObjective = -Infinity;\n    let hasValidSolution = false;\n    for(let w = feasible_min; w <= dynamicMax; w += grid_step){\n        const u_E = utilityEmployer(w, negotiationBreakdownCost);\n        const u_W = utilityWorker(w, workerIdeal, workerMinimum);\n        // 跳过无效区域\n        if (u_E <= u_E0 || u_W <= u_W0) continue;\n        hasValidSolution = true;\n        const objective = Math.pow(u_E - u_E0, beta) * Math.pow(u_W - u_W0, 1 - beta);\n        if (objective > maxObjective) {\n            maxObjective = objective;\n            bestWage = w;\n        } else if (objective === maxObjective) {\n            // 如果目标函数相等，选择更接近区间中点的\n            const midpoint = (feasible_min + dynamicMax) / 2;\n            if (Math.abs(w - midpoint) < Math.abs(bestWage - midpoint)) {\n                bestWage = w;\n            }\n        }\n    }\n    // 如果没有找到有效解，返回null\n    if (!hasValidSolution) {\n        return null;\n    }\n    return bestWage;\n}\n// 计算工人底线工资\nfunction calculateWorkerWalkAway(u_W0, workerIdeal, workerMinimum) {\n    const { feasible_min, feasible_max, grid_step } = CONSTANTS;\n    const w_W_min = workerMinimum || CONSTANTS.w_W_min;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    const w_WA_raw = w_W_min + (u_W0 - 0.1) / 0.9 * (w_W_ideal - w_W_min);\n    const w_WA_clamped = clamp(w_WA_raw, feasible_min, feasible_max);\n    return roundToStep(w_WA_clamped, grid_step);\n}\n// 计算雇主无差异上限\nfunction calculateEmployerCeiling(u_E0, negotiationBreakdownCost) {\n    const { w_E_ideal, feasible_min, grid_step } = CONSTANTS;\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    const w_EMP_raw = w_E_max - (u_E0 - 0.1) / 0.9 * (w_E_max - w_E_ideal);\n    // 使用动态上限，不限制在固定的feasible_max\n    const dynamicMax = Math.max(CONSTANTS.feasible_max, w_E_max);\n    const w_EMP_clamped = clamp(w_EMP_raw, feasible_min, dynamicMax);\n    return roundToStep(w_EMP_clamped, grid_step);\n}\n// 计算ZOPA\nfunction calculateZOPA(w_WA, w_EMP) {\n    const { feasible_min } = CONSTANTS;\n    const zopa_min = Math.max(feasible_min, w_WA);\n    // 不限制ZOPA上限在固定的feasible_max，允许根据w_EMP动态调整\n    const zopa_max = w_EMP;\n    return {\n        min: zopa_min,\n        max: zopa_max,\n        valid: zopa_min <= zopa_max\n    };\n}\n// 计算工人锚点价格\nfunction calculateWorkerAnchor(w_nash, w_EMP) {\n    const { grid_step } = CONSTANTS;\n    const w_anchor_raw = Math.min(w_nash + 0.08 * (w_EMP - w_nash), w_EMP);\n    return roundToStep(w_anchor_raw, grid_step);\n}\n// 计算期望区间\nfunction calculateAspirationBand(w_nash, w_WA, w_EMP) {\n    const { grid_step } = CONSTANTS;\n    const w_top_raw = Math.min(w_nash + 0.15 * (w_EMP - w_WA), w_EMP);\n    const w_floor_raw = Math.max(w_WA, w_nash - 0.05 * (w_nash - w_WA));\n    return {\n        top: roundToStep(w_top_raw, grid_step),\n        floor: roundToStep(w_floor_raw, grid_step)\n    };\n}\n// 主计算函数\nfunction calculateNegotiationPlan(policyValue, customAsk, negotiationBreakdownCost, localMinimumWage, workerIdeal, workerMinimum) {\n    const policy = POLICY_OPTIONS.find((p)=>p.value === policyValue) || POLICY_OPTIONS[2];\n    const beta = policy.beta;\n    const { u_E0, u_W0 } = calculateUtilityFloors(negotiationBreakdownCost, localMinimumWage, workerIdeal, workerMinimum);\n    const w_WA = calculateWorkerWalkAway(u_W0, workerIdeal, workerMinimum);\n    const w_EMP = calculateEmployerCeiling(u_E0, negotiationBreakdownCost);\n    const zopa = calculateZOPA(w_WA, w_EMP);\n    const w_nash = calculateNashSolution(beta, u_E0, u_W0, negotiationBreakdownCost, workerIdeal, workerMinimum);\n    // 检查是否有Nash解\n    if (w_nash === null) {\n        return {\n            policy,\n            beta,\n            u_E0,\n            u_W0,\n            w_nash: null,\n            w_anchor: null,\n            w_WA,\n            w_EMP,\n            zopa,\n            aspirationBand: null,\n            coefficients: {\n                c_nash: null,\n                c_anchor: null,\n                c_ask: customAsk ? customAsk / CONSTANTS.base : undefined\n            },\n            customAsk,\n            hasValidSolution: false,\n            errorMessage: \"工资期望过高，雇主效用不足，Nash解不存在\"\n        };\n    }\n    const w_anchor = calculateWorkerAnchor(w_nash, w_EMP);\n    const aspirationBand = calculateAspirationBand(w_nash, w_WA, w_EMP);\n    // 转换为加班系数\n    const c_nash = w_nash / CONSTANTS.base;\n    const c_anchor = w_anchor / CONSTANTS.base;\n    const c_ask = customAsk ? customAsk / CONSTANTS.base : undefined;\n    return {\n        policy,\n        beta,\n        u_E0,\n        u_W0,\n        w_nash,\n        w_anchor,\n        w_WA,\n        w_EMP,\n        zopa,\n        aspirationBand,\n        coefficients: {\n            c_nash,\n            c_anchor,\n            c_ask\n        },\n        customAsk,\n        hasValidSolution: true\n    };\n}\n// 生成图表数据\nfunction generateChartData(u_E0, u_W0, negotiationBreakdownCost, workerIdeal, workerMinimum) {\n    const { feasible_min, grid_step } = CONSTANTS;\n    // 动态调整图表数据范围\n    const w_E_max = negotiationBreakdownCost || CONSTANTS.w_E_max;\n    const w_W_ideal = workerIdeal || CONSTANTS.w_W_ideal;\n    const dynamicMax = Math.max(CONSTANTS.feasible_max, w_E_max, w_W_ideal);\n    const data = [];\n    for(let w = feasible_min; w <= dynamicMax; w += grid_step){\n        const u_E = utilityEmployer(w, negotiationBreakdownCost);\n        const u_W = utilityWorker(w, workerIdeal, workerMinimum);\n        data.push({\n            wage: w,\n            u_E,\n            u_W,\n            nashProduct: u_E > u_E0 && u_W > u_W0 ? (u_E - u_E0) * (u_W - u_W0) : 0\n        });\n    }\n    return data;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGNBQWM0QixLQUFLRyxZQUFZSCxLQUFLMUIsVUFBVztRQUMxRCxNQUFNa0MsTUFBTVQsZ0JBQWdCQyxHQUFHWDtRQUMvQixNQUFNb0IsTUFBTVIsY0FBY0QsR0FBR1QsYUFBYUM7UUFFMUMwRCxLQUFLQyxJQUFJLENBQUM7WUFDUkMsTUFBTXBEO1lBQ05RO1lBQ0FDO1lBQ0E0QyxhQUFhLE1BQU94RCxRQUFRWSxNQUFNWCxPQUFRLENBQUNVLE1BQU1YLElBQUcsSUFBTVksQ0FBQUEsTUFBTVgsSUFBRyxJQUFLO1FBQzFFO0lBQ0Y7SUFFQSxPQUFPb0Q7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvY2FsY3VsYXRpb25zLnRzPzNmNzciXSwic291cmNlc0NvbnRlbnQiOlsiLy8g5bi46YeP5a6a5LmJXG5leHBvcnQgY29uc3QgQ09OU1RBTlRTID0ge1xuICBiYXNlOiAyNTAwLFxuICB3X0VfaWRlYWw6IDI1MDAsXG4gIHdfRV9tYXg6IDgwMDAsXG4gIHdfV19taW46IDM1MDAsXG4gIHdfV19pZGVhbDogODAwMCxcbiAgZmVhc2libGVfbWluOiAzNTAwLFxuICBmZWFzaWJsZV9tYXg6IDgwMDAsXG4gIGdyaWRfc3RlcDogNTAsXG4gIGVtcGxveWVyX2ZhbGxiYWNrX2Nvc3RfbW9uZXk6IDYwMDAsXG4gIHdvcmtlcl9mYWxsYmFja19pbmNvbWVfbW9uZXk6IDI0OTBcbn07XG5cbi8vIOaUv+etluaDheaZr+aYoOWwhFxuZXhwb3J0IGNvbnN0IFBPTElDWV9PUFRJT05TID0gW1xuICB7IGxhYmVsOiBcIuS4gOiIrOS/neaKpO+8iOW4guWcuuS4u+WvvO+8iVwiLCB2YWx1ZTogXCJtYXJrZXRcIiwgYmV0YTogMC40OCB9LFxuICB7IGxhYmVsOiBcIuS4reW6puS/neaKpO+8iOWBj+WQkeW3peS6uu+8iVwiLCB2YWx1ZTogXCJtb2RlcmF0ZVwiLCBiZXRhOiAwLjQyIH0sXG4gIHsgbGFiZWw6IFwi6L6D5by65L+d5oqk77yI6ZuG5L2T6LCI5Yik77yJXCIsIHZhbHVlOiBcInN0cm9uZ1wiLCBiZXRhOiAwLjM1IH0sXG4gIHsgbGFiZWw6IFwi5by65L+d5oqk77yI5by65bel5LyaL+W8uuebkeeuoe+8iVwiLCB2YWx1ZTogXCJzdHJvbmdlc3RcIiwgYmV0YTogMC4yOCB9XG5dO1xuXG4vLyDlpLnpgLzlh73mlbBcbmZ1bmN0aW9uIGNsYW1wKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cblxuLy8g5Zub6IiN5LqU5YWl5Yiw5pyA6L+R55qE5q2l6ZW/XG5mdW5jdGlvbiByb3VuZFRvU3RlcCh2YWx1ZTogbnVtYmVyLCBzdGVwOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIHN0ZXApICogc3RlcDtcbn1cblxuLy8g6K6h566XUGxhbiBC5pig5bCE55qE5pWI55So5bqV57q/XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlVXRpbGl0eUZsb29ycyhuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3Q/OiBudW1iZXIsIGxvY2FsTWluaW11bVdhZ2U/OiBudW1iZXIsIHdvcmtlcklkZWFsPzogbnVtYmVyLCB3b3JrZXJNaW5pbXVtPzogbnVtYmVyKSB7XG4gIGNvbnN0IHsgd19FX2lkZWFsIH0gPSBDT05TVEFOVFM7XG4gIFxuICAvLyDkvb/nlKjliqjmgIHlj4LmlbDmiJbpu5jorqTlgLxcbiAgY29uc3Qgd19FX21heCA9IG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdCB8fCBDT05TVEFOVFMud19FX21heDtcbiAgY29uc3QgZW1wbG95ZXJfZmFsbGJhY2tfY29zdCA9IG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdCB8fCBDT05TVEFOVFMuZW1wbG95ZXJfZmFsbGJhY2tfY29zdF9tb25leTtcbiAgY29uc3Qgd29ya2VyX2ZhbGxiYWNrX2luY29tZSA9IGxvY2FsTWluaW11bVdhZ2UgfHwgQ09OU1RBTlRTLndvcmtlcl9mYWxsYmFja19pbmNvbWVfbW9uZXk7XG4gIGNvbnN0IHdfV19taW4gPSB3b3JrZXJNaW5pbXVtIHx8IENPTlNUQU5UUy53X1dfbWluO1xuICBjb25zdCB3X1dfaWRlYWwgPSB3b3JrZXJJZGVhbCB8fCBDT05TVEFOVFMud19XX2lkZWFsO1xuICBcbiAgY29uc3QgdUUwX3JhdyA9IDAuMSArIDAuOSAqICh3X0VfbWF4IC0gZW1wbG95ZXJfZmFsbGJhY2tfY29zdCkgLyAod19FX21heCAtIHdfRV9pZGVhbCk7XG4gIGNvbnN0IHVXMF9yYXcgPSAwLjEgKyAwLjkgKiAod29ya2VyX2ZhbGxiYWNrX2luY29tZSAtIHdfV19taW4pIC8gKHdfV19pZGVhbCAtIHdfV19taW4pO1xuICBcbiAgY29uc3QgdV9FMCA9IGNsYW1wKHVFMF9yYXcsIDAuMSwgMC45KTtcbiAgY29uc3QgdV9XMCA9IGNsYW1wKHVXMF9yYXcsIDAuMSwgMC45KTtcbiAgXG4gIHJldHVybiB7IHVfRTAsIHVfVzAgfTtcbn1cblxuLy8g6ZuH5Li75pWI55So5Ye95pWwXG5leHBvcnQgZnVuY3Rpb24gdXRpbGl0eUVtcGxveWVyKHc6IG51bWJlciwgbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0PzogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgeyB3X0VfaWRlYWwgfSA9IENPTlNUQU5UUztcbiAgY29uc3Qgd19FX21heCA9IG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdCB8fCBDT05TVEFOVFMud19FX21heDtcbiAgcmV0dXJuIGNsYW1wKDAuMSArIDAuOSAqICh3X0VfbWF4IC0gdykgLyAod19FX21heCAtIHdfRV9pZGVhbCksIDAsIDEpO1xufVxuXG4vLyDlt6XkurrmlYjnlKjlh73mlbBcbmV4cG9ydCBmdW5jdGlvbiB1dGlsaXR5V29ya2VyKHc6IG51bWJlciwgd29ya2VySWRlYWw/OiBudW1iZXIsIHdvcmtlck1pbmltdW0/OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB3X1dfbWluID0gd29ya2VyTWluaW11bSB8fCBDT05TVEFOVFMud19XX21pbjtcbiAgY29uc3Qgd19XX2lkZWFsID0gd29ya2VySWRlYWwgfHwgQ09OU1RBTlRTLndfV19pZGVhbDtcbiAgcmV0dXJuIGNsYW1wKDAuMSArIDAuOSAqICh3IC0gd19XX21pbikgLyAod19XX2lkZWFsIC0gd19XX21pbiksIDAsIDEpO1xufVxuXG4vLyBOYXNo6LCI5Yik6KejXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTmFzaFNvbHV0aW9uKGJldGE6IG51bWJlciwgdV9FMDogbnVtYmVyLCB1X1cwOiBudW1iZXIsIG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdD86IG51bWJlciwgd29ya2VySWRlYWw/OiBudW1iZXIsIHdvcmtlck1pbmltdW0/OiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgY29uc3QgeyBmZWFzaWJsZV9taW4sIGdyaWRfc3RlcCB9ID0gQ09OU1RBTlRTO1xuICAvLyDliqjmgIHosIPmlbTmkJzntKLkuIrpmZDvvIzogIPomZHnlKjmiLfovpPlhaXnmoTlj4LmlbBcbiAgY29uc3Qgd19FX21heCA9IG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdCB8fCBDT05TVEFOVFMud19FX21heDtcbiAgY29uc3Qgd19XX2lkZWFsID0gd29ya2VySWRlYWwgfHwgQ09OU1RBTlRTLndfV19pZGVhbDtcbiAgY29uc3QgZHluYW1pY01heCA9IE1hdGgubWF4KENPTlNUQU5UUy5mZWFzaWJsZV9tYXgsIHdfRV9tYXgsIHdfV19pZGVhbCk7XG4gIFxuICBsZXQgYmVzdFdhZ2UgPSBmZWFzaWJsZV9taW47XG4gIGxldCBtYXhPYmplY3RpdmUgPSAtSW5maW5pdHk7XG4gIGxldCBoYXNWYWxpZFNvbHV0aW9uID0gZmFsc2U7XG4gIFxuICBmb3IgKGxldCB3ID0gZmVhc2libGVfbWluOyB3IDw9IGR5bmFtaWNNYXg7IHcgKz0gZ3JpZF9zdGVwKSB7XG4gICAgY29uc3QgdV9FID0gdXRpbGl0eUVtcGxveWVyKHcsIG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdCk7XG4gICAgY29uc3QgdV9XID0gdXRpbGl0eVdvcmtlcih3LCB3b3JrZXJJZGVhbCwgd29ya2VyTWluaW11bSk7XG4gICAgXG4gICAgLy8g6Lez6L+H5peg5pWI5Yy65Z+fXG4gICAgaWYgKHVfRSA8PSB1X0UwIHx8IHVfVyA8PSB1X1cwKSBjb250aW51ZTtcbiAgICBcbiAgICBoYXNWYWxpZFNvbHV0aW9uID0gdHJ1ZTtcbiAgICBjb25zdCBvYmplY3RpdmUgPSBNYXRoLnBvdyh1X0UgLSB1X0UwLCBiZXRhKSAqIE1hdGgucG93KHVfVyAtIHVfVzAsIDEgLSBiZXRhKTtcbiAgICBcbiAgICBpZiAob2JqZWN0aXZlID4gbWF4T2JqZWN0aXZlKSB7XG4gICAgICBtYXhPYmplY3RpdmUgPSBvYmplY3RpdmU7XG4gICAgICBiZXN0V2FnZSA9IHc7XG4gICAgfSBlbHNlIGlmIChvYmplY3RpdmUgPT09IG1heE9iamVjdGl2ZSkge1xuICAgICAgLy8g5aaC5p6c55uu5qCH5Ye95pWw55u4562J77yM6YCJ5oup5pu05o6l6L+R5Yy66Ze05Lit54K555qEXG4gICAgICBjb25zdCBtaWRwb2ludCA9IChmZWFzaWJsZV9taW4gKyBkeW5hbWljTWF4KSAvIDI7XG4gICAgICBpZiAoTWF0aC5hYnModyAtIG1pZHBvaW50KSA8IE1hdGguYWJzKGJlc3RXYWdlIC0gbWlkcG9pbnQpKSB7XG4gICAgICAgIGJlc3RXYWdlID0gdztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIOWmguaenOayoeacieaJvuWIsOacieaViOino++8jOi/lOWbnm51bGxcbiAgaWYgKCFoYXNWYWxpZFNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIHJldHVybiBiZXN0V2FnZTtcbn1cblxuLy8g6K6h566X5bel5Lq65bqV57q/5bel6LWEXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlV29ya2VyV2Fsa0F3YXkodV9XMDogbnVtYmVyLCB3b3JrZXJJZGVhbD86IG51bWJlciwgd29ya2VyTWluaW11bT86IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHsgZmVhc2libGVfbWluLCBmZWFzaWJsZV9tYXgsIGdyaWRfc3RlcCB9ID0gQ09OU1RBTlRTO1xuICBjb25zdCB3X1dfbWluID0gd29ya2VyTWluaW11bSB8fCBDT05TVEFOVFMud19XX21pbjtcbiAgY29uc3Qgd19XX2lkZWFsID0gd29ya2VySWRlYWwgfHwgQ09OU1RBTlRTLndfV19pZGVhbDtcbiAgXG4gIGNvbnN0IHdfV0FfcmF3ID0gd19XX21pbiArICgodV9XMCAtIDAuMSkgLyAwLjkpICogKHdfV19pZGVhbCAtIHdfV19taW4pO1xuICBjb25zdCB3X1dBX2NsYW1wZWQgPSBjbGFtcCh3X1dBX3JhdywgZmVhc2libGVfbWluLCBmZWFzaWJsZV9tYXgpO1xuICBcbiAgcmV0dXJuIHJvdW5kVG9TdGVwKHdfV0FfY2xhbXBlZCwgZ3JpZF9zdGVwKTtcbn1cblxuLy8g6K6h566X6ZuH5Li75peg5beu5byC5LiK6ZmQXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRW1wbG95ZXJDZWlsaW5nKHVfRTA6IG51bWJlciwgbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0PzogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgeyB3X0VfaWRlYWwsIGZlYXNpYmxlX21pbiwgZ3JpZF9zdGVwIH0gPSBDT05TVEFOVFM7XG4gIGNvbnN0IHdfRV9tYXggPSBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QgfHwgQ09OU1RBTlRTLndfRV9tYXg7XG4gIFxuICBjb25zdCB3X0VNUF9yYXcgPSB3X0VfbWF4IC0gKCh1X0UwIC0gMC4xKSAvIDAuOSkgKiAod19FX21heCAtIHdfRV9pZGVhbCk7XG4gIC8vIOS9v+eUqOWKqOaAgeS4iumZkO+8jOS4jemZkOWItuWcqOWbuuWumueahGZlYXNpYmxlX21heFxuICBjb25zdCBkeW5hbWljTWF4ID0gTWF0aC5tYXgoQ09OU1RBTlRTLmZlYXNpYmxlX21heCwgd19FX21heCk7XG4gIGNvbnN0IHdfRU1QX2NsYW1wZWQgPSBjbGFtcCh3X0VNUF9yYXcsIGZlYXNpYmxlX21pbiwgZHluYW1pY01heCk7XG4gIFxuICByZXR1cm4gcm91bmRUb1N0ZXAod19FTVBfY2xhbXBlZCwgZ3JpZF9zdGVwKTtcbn1cblxuLy8g6K6h566XWk9QQVxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVpPUEEod19XQTogbnVtYmVyLCB3X0VNUDogbnVtYmVyKTogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXI7IHZhbGlkOiBib29sZWFuIH0ge1xuICBjb25zdCB7IGZlYXNpYmxlX21pbiB9ID0gQ09OU1RBTlRTO1xuICBcbiAgY29uc3Qgem9wYV9taW4gPSBNYXRoLm1heChmZWFzaWJsZV9taW4sIHdfV0EpO1xuICAvLyDkuI3pmZDliLZaT1BB5LiK6ZmQ5Zyo5Zu65a6a55qEZmVhc2libGVfbWF477yM5YWB6K645qC55o2ud19FTVDliqjmgIHosIPmlbRcbiAgY29uc3Qgem9wYV9tYXggPSB3X0VNUDtcbiAgXG4gIHJldHVybiB7XG4gICAgbWluOiB6b3BhX21pbixcbiAgICBtYXg6IHpvcGFfbWF4LFxuICAgIHZhbGlkOiB6b3BhX21pbiA8PSB6b3BhX21heFxuICB9O1xufVxuXG4vLyDorqHnrpflt6XkurrplJrngrnku7fmoLxcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVXb3JrZXJBbmNob3Iod19uYXNoOiBudW1iZXIsIHdfRU1QOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB7IGdyaWRfc3RlcCB9ID0gQ09OU1RBTlRTO1xuICBcbiAgY29uc3Qgd19hbmNob3JfcmF3ID0gTWF0aC5taW4od19uYXNoICsgMC4wOCAqICh3X0VNUCAtIHdfbmFzaCksIHdfRU1QKTtcbiAgcmV0dXJuIHJvdW5kVG9TdGVwKHdfYW5jaG9yX3JhdywgZ3JpZF9zdGVwKTtcbn1cblxuLy8g6K6h566X5pyf5pyb5Yy66Ze0XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXNwaXJhdGlvbkJhbmQod19uYXNoOiBudW1iZXIsIHdfV0E6IG51bWJlciwgd19FTVA6IG51bWJlcik6IHsgdG9wOiBudW1iZXI7IGZsb29yOiBudW1iZXIgfSB7XG4gIGNvbnN0IHsgZ3JpZF9zdGVwIH0gPSBDT05TVEFOVFM7XG4gIFxuICBjb25zdCB3X3RvcF9yYXcgPSBNYXRoLm1pbih3X25hc2ggKyAwLjE1ICogKHdfRU1QIC0gd19XQSksIHdfRU1QKTtcbiAgY29uc3Qgd19mbG9vcl9yYXcgPSBNYXRoLm1heCh3X1dBLCB3X25hc2ggLSAwLjA1ICogKHdfbmFzaCAtIHdfV0EpKTtcbiAgXG4gIHJldHVybiB7XG4gICAgdG9wOiByb3VuZFRvU3RlcCh3X3RvcF9yYXcsIGdyaWRfc3RlcCksXG4gICAgZmxvb3I6IHJvdW5kVG9TdGVwKHdfZmxvb3JfcmF3LCBncmlkX3N0ZXApXG4gIH07XG59XG5cbi8vIOS4u+iuoeeul+WHveaVsFxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU5lZ290aWF0aW9uUGxhbihwb2xpY3lWYWx1ZTogc3RyaW5nLCBjdXN0b21Bc2s/OiBudW1iZXIsIG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdD86IG51bWJlciwgbG9jYWxNaW5pbXVtV2FnZT86IG51bWJlciwgd29ya2VySWRlYWw/OiBudW1iZXIsIHdvcmtlck1pbmltdW0/OiBudW1iZXIpIHtcbiAgY29uc3QgcG9saWN5ID0gUE9MSUNZX09QVElPTlMuZmluZChwID0+IHAudmFsdWUgPT09IHBvbGljeVZhbHVlKSB8fCBQT0xJQ1lfT1BUSU9OU1syXTtcbiAgY29uc3QgYmV0YSA9IHBvbGljeS5iZXRhO1xuICBcbiAgY29uc3QgeyB1X0UwLCB1X1cwIH0gPSBjYWxjdWxhdGVVdGlsaXR5Rmxvb3JzKG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdCwgbG9jYWxNaW5pbXVtV2FnZSwgd29ya2VySWRlYWwsIHdvcmtlck1pbmltdW0pO1xuICBcbiAgY29uc3Qgd19XQSA9IGNhbGN1bGF0ZVdvcmtlcldhbGtBd2F5KHVfVzAsIHdvcmtlcklkZWFsLCB3b3JrZXJNaW5pbXVtKTtcbiAgY29uc3Qgd19FTVAgPSBjYWxjdWxhdGVFbXBsb3llckNlaWxpbmcodV9FMCwgbmVnb3RpYXRpb25CcmVha2Rvd25Db3N0KTtcbiAgY29uc3Qgem9wYSA9IGNhbGN1bGF0ZVpPUEEod19XQSwgd19FTVApO1xuICBcbiAgY29uc3Qgd19uYXNoID0gY2FsY3VsYXRlTmFzaFNvbHV0aW9uKGJldGEsIHVfRTAsIHVfVzAsIG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdCwgd29ya2VySWRlYWwsIHdvcmtlck1pbmltdW0pO1xuICBcbiAgLy8g5qOA5p+l5piv5ZCm5pyJTmFzaOino1xuICBpZiAod19uYXNoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvbGljeSxcbiAgICAgIGJldGEsXG4gICAgICB1X0UwLFxuICAgICAgdV9XMCxcbiAgICAgIHdfbmFzaDogbnVsbCxcbiAgICAgIHdfYW5jaG9yOiBudWxsLFxuICAgICAgd19XQSxcbiAgICAgIHdfRU1QLFxuICAgICAgem9wYSxcbiAgICAgIGFzcGlyYXRpb25CYW5kOiBudWxsLFxuICAgICAgY29lZmZpY2llbnRzOiB7XG4gICAgICAgIGNfbmFzaDogbnVsbCxcbiAgICAgICAgY19hbmNob3I6IG51bGwsXG4gICAgICAgIGNfYXNrOiBjdXN0b21Bc2sgPyBjdXN0b21Bc2sgLyBDT05TVEFOVFMuYmFzZSA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIGN1c3RvbUFzayxcbiAgICAgIGhhc1ZhbGlkU29sdXRpb246IGZhbHNlLFxuICAgICAgZXJyb3JNZXNzYWdlOiBcIuW3pei1hOacn+acm+i/h+mrmO+8jOmbh+S4u+aViOeUqOS4jei2s++8jE5hc2jop6PkuI3lrZjlnKhcIlxuICAgIH07XG4gIH1cbiAgXG4gIGNvbnN0IHdfYW5jaG9yID0gY2FsY3VsYXRlV29ya2VyQW5jaG9yKHdfbmFzaCwgd19FTVApO1xuICBjb25zdCBhc3BpcmF0aW9uQmFuZCA9IGNhbGN1bGF0ZUFzcGlyYXRpb25CYW5kKHdfbmFzaCwgd19XQSwgd19FTVApO1xuICBcbiAgLy8g6L2s5o2i5Li65Yqg54+t57O75pWwXG4gIGNvbnN0IGNfbmFzaCA9IHdfbmFzaCAvIENPTlNUQU5UUy5iYXNlO1xuICBjb25zdCBjX2FuY2hvciA9IHdfYW5jaG9yIC8gQ09OU1RBTlRTLmJhc2U7XG4gIGNvbnN0IGNfYXNrID0gY3VzdG9tQXNrID8gY3VzdG9tQXNrIC8gQ09OU1RBTlRTLmJhc2UgOiB1bmRlZmluZWQ7XG4gIFxuICByZXR1cm4ge1xuICAgIHBvbGljeSxcbiAgICBiZXRhLFxuICAgIHVfRTAsXG4gICAgdV9XMCxcbiAgICB3X25hc2gsXG4gICAgd19hbmNob3IsXG4gICAgd19XQSxcbiAgICB3X0VNUCxcbiAgICB6b3BhLFxuICAgIGFzcGlyYXRpb25CYW5kLFxuICAgIGNvZWZmaWNpZW50czoge1xuICAgICAgY19uYXNoLFxuICAgICAgY19hbmNob3IsXG4gICAgICBjX2Fza1xuICAgIH0sXG4gICAgY3VzdG9tQXNrLFxuICAgIGhhc1ZhbGlkU29sdXRpb246IHRydWVcbiAgfTtcbn1cblxuLy8g5Zu+6KGo5pWw5o2u57G75Z6LXG5leHBvcnQgaW50ZXJmYWNlIENoYXJ0RGF0YVBvaW50IHtcbiAgd2FnZTogbnVtYmVyO1xuICB1X0U6IG51bWJlcjtcbiAgdV9XOiBudW1iZXI7XG4gIG5hc2hQcm9kdWN0OiBudW1iZXI7XG59XG5cbi8vIOeUn+aIkOWbvuihqOaVsOaNrlxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2hhcnREYXRhKHVfRTA6IG51bWJlciwgdV9XMDogbnVtYmVyLCBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3Q/OiBudW1iZXIsIHdvcmtlcklkZWFsPzogbnVtYmVyLCB3b3JrZXJNaW5pbXVtPzogbnVtYmVyKTogQ2hhcnREYXRhUG9pbnRbXSB7XG4gIGNvbnN0IHsgZmVhc2libGVfbWluLCBncmlkX3N0ZXAgfSA9IENPTlNUQU5UUztcbiAgLy8g5Yqo5oCB6LCD5pW05Zu+6KGo5pWw5o2u6IyD5Zu0XG4gIGNvbnN0IHdfRV9tYXggPSBuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QgfHwgQ09OU1RBTlRTLndfRV9tYXg7XG4gIGNvbnN0IHdfV19pZGVhbCA9IHdvcmtlcklkZWFsIHx8IENPTlNUQU5UUy53X1dfaWRlYWw7XG4gIGNvbnN0IGR5bmFtaWNNYXggPSBNYXRoLm1heChDT05TVEFOVFMuZmVhc2libGVfbWF4LCB3X0VfbWF4LCB3X1dfaWRlYWwpO1xuICBjb25zdCBkYXRhOiBDaGFydERhdGFQb2ludFtdID0gW107XG4gIFxuICBmb3IgKGxldCB3ID0gZmVhc2libGVfbWluOyB3IDw9IGR5bmFtaWNNYXg7IHcgKz0gZ3JpZF9zdGVwKSB7XG4gICAgY29uc3QgdV9FID0gdXRpbGl0eUVtcGxveWVyKHcsIG5lZ290aWF0aW9uQnJlYWtkb3duQ29zdCk7XG4gICAgY29uc3QgdV9XID0gdXRpbGl0eVdvcmtlcih3LCB3b3JrZXJJZGVhbCwgd29ya2VyTWluaW11bSk7XG4gICAgXG4gICAgZGF0YS5wdXNoKHtcbiAgICAgIHdhZ2U6IHcsXG4gICAgICB1X0UsXG4gICAgICB1X1csXG4gICAgICBuYXNoUHJvZHVjdDogKHVfRSA+IHVfRTAgJiYgdV9XID4gdV9XMCkgPyAodV9FIC0gdV9FMCkgKiAodV9XIC0gdV9XMCkgOiAwXG4gICAgfSk7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhO1xufSJdLCJuYW1lcyI6WyJDT05TVEFOVFMiLCJiYXNlIiwid19FX2lkZWFsIiwid19FX21heCIsIndfV19taW4iLCJ3X1dfaWRlYWwiLCJmZWFzaWJsZV9taW4iLCJmZWFzaWJsZV9tYXgiLCJncmlkX3N0ZXAiLCJlbXBsb3llcl9mYWxsYmFja19jb3N0X21vbmV5Iiwid29ya2VyX2ZhbGxiYWNrX2luY29tZV9tb25leSIsIlBPTElDWV9PUFRJT05TIiwibGFiZWwiLCJ2YWx1ZSIsImJldGEiLCJjbGFtcCIsIm1pbiIsIm1heCIsIk1hdGgiLCJyb3VuZFRvU3RlcCIsInN0ZXAiLCJyb3VuZCIsImNhbGN1bGF0ZVV0aWxpdHlGbG9vcnMiLCJuZWdvdGlhdGlvbkJyZWFrZG93bkNvc3QiLCJsb2NhbE1pbmltdW1XYWdlIiwid29ya2VySWRlYWwiLCJ3b3JrZXJNaW5pbXVtIiwiZW1wbG95ZXJfZmFsbGJhY2tfY29zdCIsIndvcmtlcl9mYWxsYmFja19pbmNvbWUiLCJ1RTBfcmF3IiwidVcwX3JhdyIsInVfRTAiLCJ1X1cwIiwidXRpbGl0eUVtcGxveWVyIiwidyIsInV0aWxpdHlXb3JrZXIiLCJjYWxjdWxhdGVOYXNoU29sdXRpb24iLCJkeW5hbWljTWF4IiwiYmVzdFdhZ2UiLCJtYXhPYmplY3RpdmUiLCJJbmZpbml0eSIsImhhc1ZhbGlkU29sdXRpb24iLCJ1X0UiLCJ1X1ciLCJvYmplY3RpdmUiLCJwb3ciLCJtaWRwb2ludCIsImFicyIsImNhbGN1bGF0ZVdvcmtlcldhbGtBd2F5Iiwid19XQV9yYXciLCJ3X1dBX2NsYW1wZWQiLCJjYWxjdWxhdGVFbXBsb3llckNlaWxpbmciLCJ3X0VNUF9yYXciLCJ3X0VNUF9jbGFtcGVkIiwiY2FsY3VsYXRlWk9QQSIsIndfV0EiLCJ3X0VNUCIsInpvcGFfbWluIiwiem9wYV9tYXgiLCJ2YWxpZCIsImNhbGN1bGF0ZVdvcmtlckFuY2hvciIsIndfbmFzaCIsIndfYW5jaG9yX3JhdyIsImNhbGN1bGF0ZUFzcGlyYXRpb25CYW5kIiwid190b3BfcmF3Iiwid19mbG9vcl9yYXciLCJ0b3AiLCJmbG9vciIsImNhbGN1bGF0ZU5lZ290aWF0aW9uUGxhbiIsInBvbGljeVZhbHVlIiwiY3VzdG9tQXNrIiwicG9saWN5IiwiZmluZCIsInAiLCJ6b3BhIiwid19hbmNob3IiLCJhc3BpcmF0aW9uQmFuZCIsImNvZWZmaWNpZW50cyIsImNfbmFzaCIsImNfYW5jaG9yIiwiY19hc2siLCJ1bmRlZmluZWQiLCJlcnJvck1lc3NhZ2UiLCJnZW5lcmF0ZUNoYXJ0RGF0YSIsImRhdGEiLCJwdXNoIiwid2FnZSIsIm5hc2hQcm9kdWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/calculations.ts\n"));

/***/ })

});